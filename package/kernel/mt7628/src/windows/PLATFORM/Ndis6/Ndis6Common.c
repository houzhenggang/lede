/*
 ***************************************************************************
 * MediaTek Inc.
 * 5F, No.5, Tai-Yuan 1st St., 
 * Chupei City, Hsinchu County 30265, Taiwan, R.O.C.
 *
 * (c) Copyright 2014-2016, MediaTek, Inc.
 *
 * All rights reserved. MediaTek's source code is an unpublished work and the
 * use of a copyright notice does not imply otherwise. This source code
 * contains confidential trade secret material of MediaTek. Any attemp
 * or participation in deciphering, decoding, reverse engineering or in any
 * way altering the source code is stricitly prohibited, unless the prior
 * written consent of MediaTek, Inc. is obtained.
 ***************************************************************************

    Module Name:
    Ndis6Common.h

    Abstract:
    Miniport generic portion header file

    Revision History:
    Who         When          What
    --------    ----------    ----------------------------------------------
    */
    

#include    "MtConfig.h"
#include "Ndis6Common.h"

ULONG    G_MemoryAllocate_cnt = 0;
ULONG    G_MemoryFree_cnt = 0;
ULONG    G_MemoryAllocate_Len = 0;
ULONG    G_MemoryFree_Len = 0;

ULONG    TIM_BITMAP[] = {0x00000001, 0x00000002, 0x00000004, 0x00000008,
                    0x00000010, 0x00000020, 0x00000040, 0x00000080,
                    0x00000100, 0x00000200, 0x00000400, 0x00000800,
                    0x00001000, 0x00002000, 0x00004000, 0x00008000,
                    0x00010000, 0x00020000, 0x00040000, 0x00080000,
                    0x00100000, 0x00200000, 0x00400000, 0x00800000,
                    0x01000000, 0x02000000, 0x04000000, 0x08000000,
                    0x10000000, 0x20000000, 0x40000000, 0x80000000};

char*   CipherName[] = {"none","wep64","wep128","TKIP","AES","CKIP64","CKIP104","CKIP128","SMS4","TKIP_NO_MIC"};

const unsigned short ccitt_16Table[] = {
    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
    0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
    0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
    0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
    0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
    0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
    0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
    0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
    0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
    0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
    0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
    0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
    0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
    0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
    0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
    0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
    0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
    0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
    0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
    0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
    0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
    0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
    0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
    0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
    0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
    0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
    0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
    0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
    0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
    0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
    0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
    0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
};
#define ByteCRC16(v, crc) \
    (unsigned short)((crc << 8) ^  ccitt_16Table[((crc >> 8) ^ (v)) & 255])

unsigned char BitReverse(unsigned char x)
{
    int i;
    unsigned char Temp=0;
    for(i=0; ; i++)
    {
        if(x & 0x80)    Temp |= 0x80;
        if(i==7)        break;
        x   <<= 1;
        Temp >>= 1;
    }
    return Temp;
}

#if DBG
PCHAR 
DbgGetOidName(
    ULONG Oid
    )
{
    PCHAR oidName;

    switch (Oid){

        #undef MAKECASE
        #define MAKECASE(oidx) case oidx: oidName = #oidx; break;

        MAKECASE(OID_GEN_STATISTICS)
        MAKECASE(OID_GEN_SUPPORTED_LIST)
        MAKECASE(OID_GEN_HARDWARE_STATUS)
        MAKECASE(OID_GEN_MEDIA_SUPPORTED)
        MAKECASE(OID_GEN_MEDIA_IN_USE)
        MAKECASE(OID_GEN_MAXIMUM_LOOKAHEAD)
        MAKECASE(OID_GEN_MAXIMUM_FRAME_SIZE)
        MAKECASE(OID_GEN_LINK_SPEED)
        MAKECASE(OID_GEN_TRANSMIT_BUFFER_SPACE)
        MAKECASE(OID_GEN_RECEIVE_BUFFER_SPACE)
        MAKECASE(OID_GEN_TRANSMIT_BLOCK_SIZE)
        MAKECASE(OID_GEN_RECEIVE_BLOCK_SIZE)
        MAKECASE(OID_GEN_VENDOR_ID)
        MAKECASE(OID_GEN_VENDOR_DESCRIPTION)
        MAKECASE(OID_GEN_CURRENT_PACKET_FILTER)
        MAKECASE(OID_GEN_CURRENT_LOOKAHEAD)
        MAKECASE(OID_GEN_DRIVER_VERSION)
        MAKECASE(OID_GEN_MAXIMUM_TOTAL_SIZE)
        MAKECASE(OID_GEN_PROTOCOL_OPTIONS)
        MAKECASE(OID_GEN_MAC_OPTIONS)
        MAKECASE(OID_GEN_MEDIA_CONNECT_STATUS)
        MAKECASE(OID_GEN_MAXIMUM_SEND_PACKETS)
        MAKECASE(OID_GEN_VENDOR_DRIVER_VERSION)
        MAKECASE(OID_GEN_SUPPORTED_GUIDS)
        MAKECASE(OID_GEN_NETWORK_LAYER_ADDRESSES)
        MAKECASE(OID_GEN_TRANSPORT_HEADER_OFFSET)
        MAKECASE(OID_GEN_MEDIA_CAPABILITIES)
        MAKECASE(OID_GEN_PHYSICAL_MEDIUM)
        MAKECASE(OID_GEN_XMIT_OK)
        MAKECASE(OID_GEN_RCV_OK)
        MAKECASE(OID_GEN_XMIT_ERROR)
        MAKECASE(OID_GEN_RCV_ERROR)
        MAKECASE(OID_GEN_RCV_NO_BUFFER)
        MAKECASE(OID_GEN_RCV_CRC_ERROR)
        MAKECASE(OID_GEN_TRANSMIT_QUEUE_LENGTH)
        MAKECASE(OID_802_3_PERMANENT_ADDRESS)
        MAKECASE(OID_DOT11_PERMANENT_ADDRESS)
        MAKECASE(OID_802_3_CURRENT_ADDRESS)
        MAKECASE(OID_DOT11_CURRENT_ADDRESS)
        MAKECASE(OID_802_3_MULTICAST_LIST)
        MAKECASE(OID_DOT11_MULTICAST_LIST)
        MAKECASE(OID_802_3_MAXIMUM_LIST_SIZE)
        MAKECASE(OID_PNP_SET_POWER)
        MAKECASE(OID_PNP_QUERY_POWER)
        MAKECASE(OID_PM_PARAMETERS)
        // For Native Wi-Fi drivers these OIDs are handled by the Native Wi-Fi filter
        /*
        OID_GEN_STATISTICS,

        */

         // ExtAP specific OIDs
        MAKECASE(OID_DOT11_DTIM_PERIOD)
        MAKECASE(OID_DOT11_AVAILABLE_CHANNEL_LIST)
        MAKECASE(OID_DOT11_AVAILABLE_FREQUENCY_LIST)
        MAKECASE(OID_DOT11_ENUM_PEER_INFO)
        MAKECASE(OID_DOT11_DISASSOCIATE_PEER_REQUEST)
        MAKECASE(OID_DOT11_PORT_STATE_NOTIFICATION)
        MAKECASE(OID_DOT11_INCOMING_ASSOCIATION_DECISION)
        MAKECASE(OID_DOT11_ADDITIONAL_IE)
        MAKECASE(OID_DOT11_WPS_ENABLED)
        MAKECASE(OID_DOT11_START_AP_REQUEST)

        // Virtual WiFi specifc OIDs
        MAKECASE(OID_DOT11_CREATE_MAC)
        MAKECASE(OID_DOT11_DELETE_MAC)        
        MAKECASE(OID_DOT11_VIRTUAL_STATION_CAPABILITY)        

        // Miniport does not support Wakeup today
        /*
        OID_PNP_CAPABILITIES,
        OID_PNP_ADD_WAKE_UP_PATTERN,
        OID_PNP_REMOVE_WAKE_UP_PATTERN,
        OID_PNP_ENABLE_WAKE_UP,
        */
        MAKECASE(OID_DOT11_MPDU_MAX_LENGTH)
        MAKECASE(OID_DOT11_OPERATION_MODE_CAPABILITY)
        MAKECASE(OID_DOT11_CURRENT_OPERATION_MODE)
        MAKECASE(OID_DOT11_ATIM_WINDOW)
        MAKECASE(OID_DOT11_SCAN_REQUEST)
        MAKECASE(OID_DOT11_RESET_REQUEST)
        MAKECASE(OID_DOT11_NIC_POWER_STATE)
        MAKECASE(OID_DOT11_OPTIONAL_CAPABILITY)
        MAKECASE(OID_DOT11_CURRENT_OPTIONAL_CAPABILITY)
        MAKECASE(OID_DOT11_STATION_ID)
        MAKECASE(OID_DOT11_CF_POLLABLE)
        MAKECASE(OID_DOT11_OPERATIONAL_RATE_SET)
        MAKECASE(OID_DOT11_BEACON_PERIOD)
        MAKECASE(OID_DOT11_MAC_ADDRESS)
        MAKECASE(OID_DOT11_RTS_THRESHOLD)
        MAKECASE(OID_DOT11_SHORT_RETRY_LIMIT)
        MAKECASE(OID_DOT11_LONG_RETRY_LIMIT)
        MAKECASE(OID_DOT11_FRAGMENTATION_THRESHOLD)
        MAKECASE(OID_DOT11_MAX_TRANSMIT_MSDU_LIFETIME)
        MAKECASE(OID_DOT11_MAX_RECEIVE_LIFETIME)
        MAKECASE(OID_DOT11_SUPPORTED_PHY_TYPES)
        MAKECASE(OID_DOT11_CURRENT_REG_DOMAIN)
        MAKECASE(OID_DOT11_TEMP_TYPE)
        MAKECASE(OID_DOT11_DIVERSITY_SUPPORT)
        MAKECASE(OID_DOT11_SUPPORTED_POWER_LEVELS)
        MAKECASE(OID_DOT11_CURRENT_TX_POWER_LEVEL)
        MAKECASE(OID_DOT11_CURRENT_CHANNEL)
        MAKECASE(OID_DOT11_CCA_MODE_SUPPORTED)
        MAKECASE(OID_DOT11_CURRENT_CCA_MODE)
        MAKECASE(OID_DOT11_ED_THRESHOLD)
        MAKECASE(OID_DOT11_REG_DOMAINS_SUPPORT_VALUE)
        MAKECASE(OID_DOT11_SUPPORTED_TX_ANTENNA)
        MAKECASE(OID_DOT11_SUPPORTED_RX_ANTENNA)
        MAKECASE(OID_DOT11_DIVERSITY_SELECTION_RX)
        MAKECASE(OID_DOT11_SUPPORTED_DATA_RATES_VALUE)
        MAKECASE(OID_DOT11_RF_USAGE)
        MAKECASE(OID_DOT11_RECV_SENSITIVITY_LIST)
        MAKECASE(OID_DOT11_MULTI_DOMAIN_CAPABILITY_IMPLEMENTED)
        MAKECASE(OID_DOT11_MULTI_DOMAIN_CAPABILITY_ENABLED)
        MAKECASE(OID_DOT11_COUNTRY_STRING)
        MAKECASE(OID_DOT11_CURRENT_FREQUENCY)
        MAKECASE(OID_DOT11_FREQUENCY_BANDS_SUPPORTED)
        MAKECASE(OID_DOT11_SHORT_PREAMBLE_OPTION_IMPLEMENTED)
        MAKECASE(OID_DOT11_PBCC_OPTION_IMPLEMENTED)
        MAKECASE(OID_DOT11_ERP_PBCC_OPTION_IMPLEMENTED)
        MAKECASE(OID_DOT11_ERP_PBCC_OPTION_ENABLED)
        MAKECASE(OID_DOT11_DSSS_OFDM_OPTION_IMPLEMENTED)
        MAKECASE(OID_DOT11_DSSS_OFDM_OPTION_ENABLED)
        MAKECASE(OID_DOT11_SHORT_SLOT_TIME_OPTION_IMPLEMENTED)
        MAKECASE(OID_DOT11_SHORT_SLOT_TIME_OPTION_ENABLED)
        MAKECASE(OID_DOT11_ENUM_BSS_LIST)
        MAKECASE(OID_DOT11_FLUSH_BSS_LIST)
        MAKECASE(OID_DOT11_POWER_MGMT_REQUEST)
        MAKECASE(OID_DOT11_DESIRED_SSID_LIST)
        MAKECASE(OID_DOT11_EXCLUDED_MAC_ADDRESS_LIST)
        MAKECASE(OID_DOT11_EXCLUDE_UNENCRYPTED)
        MAKECASE(OID_DOT11_DESIRED_BSSID_LIST)
        MAKECASE(OID_DOT11_DESIRED_BSS_TYPE)
        MAKECASE(OID_DOT11_CONNECT_REQUEST)
        MAKECASE(OID_DOT11_STATISTICS)
        MAKECASE(OID_DOT11_ENABLED_AUTHENTICATION_ALGORITHM)
        MAKECASE(OID_DOT11_SUPPORTED_UNICAST_ALGORITHM_PAIR)
        MAKECASE(OID_DOT11_SUPPORTED_MULTICAST_ALGORITHM_PAIR)
        MAKECASE(OID_DOT11_ENABLED_UNICAST_CIPHER_ALGORITHM)
        MAKECASE(OID_DOT11_ENABLED_MULTICAST_CIPHER_ALGORITHM)
        MAKECASE(OID_DOT11_CIPHER_DEFAULT_KEY_ID)
        MAKECASE(OID_DOT11_CIPHER_DEFAULT_KEY)
        MAKECASE(OID_DOT11_CIPHER_KEY_MAPPING_KEY)
        MAKECASE(OID_DOT11_ENUM_ASSOCIATION_INFO)
        MAKECASE(OID_DOT11_DISCONNECT_REQUEST)
        MAKECASE(OID_DOT11_HARDWARE_PHY_STATE)
        MAKECASE(OID_DOT11_DESIRED_PHY_LIST)
        MAKECASE(OID_DOT11_CURRENT_PHY_ID)
        MAKECASE(OID_DOT11_MEDIA_STREAMING_ENABLED)
        MAKECASE(OID_DOT11_UNREACHABLE_DETECTION_THRESHOLD)
        MAKECASE(OID_DOT11_ACTIVE_PHY_LIST)
        MAKECASE(OID_DOT11_EXTSTA_CAPABILITY)
        MAKECASE(OID_DOT11_DATA_RATE_MAPPING_TABLE)
        MAKECASE(OID_DOT11_PRIVACY_EXEMPTION_LIST)
        MAKECASE(OID_DOT11_IBSS_PARAMS)
        MAKECASE(OID_DOT11_PMKID_LIST)
        MAKECASE(OID_DOT11_AUTO_CONFIG_ENABLED)
        MAKECASE(OID_DOT11_UNICAST_USE_GROUP_ENABLED)
        MAKECASE(OID_DOT11_SAFE_MODE_ENABLED)
        MAKECASE(OID_DOT11_HIDDEN_NETWORK_ENABLED)
        MAKECASE(OID_DOT11_QOS_PARAMS)

        MAKECASE(OID_GEN_DIRECTED_BYTES_XMIT)
        MAKECASE(OID_GEN_DIRECTED_FRAMES_XMIT)
        MAKECASE(OID_GEN_MULTICAST_BYTES_XMIT)
        MAKECASE(OID_GEN_MULTICAST_FRAMES_XMIT)
        MAKECASE(OID_GEN_BROADCAST_BYTES_XMIT)
        MAKECASE(OID_GEN_BROADCAST_FRAMES_XMIT)
        MAKECASE(OID_GEN_DIRECTED_BYTES_RCV)
        MAKECASE(OID_GEN_DIRECTED_FRAMES_RCV)
        MAKECASE(OID_GEN_MULTICAST_BYTES_RCV)
        MAKECASE(OID_GEN_MULTICAST_FRAMES_RCV)
        MAKECASE(OID_GEN_BROADCAST_BYTES_RCV)
        MAKECASE(OID_GEN_BROADCAST_FRAMES_RCV)
        MAKECASE(OID_GEN_GET_TIME_CAPS)
        MAKECASE(OID_GEN_GET_NETCARD_TIME)
        MAKECASE(OID_GEN_NETCARD_LOAD)
        MAKECASE(OID_GEN_DEVICE_PROFILE)
        MAKECASE(OID_GEN_INIT_TIME_MS)
        MAKECASE(OID_GEN_RESET_COUNTS)
        MAKECASE(OID_GEN_MEDIA_SENSE_COUNTS)
        MAKECASE(OID_PNP_CAPABILITIES)
        MAKECASE(OID_PNP_ADD_WAKE_UP_PATTERN)
        MAKECASE(OID_PNP_REMOVE_WAKE_UP_PATTERN)
        MAKECASE(OID_PNP_ENABLE_WAKE_UP)
        MAKECASE(OID_802_3_MAC_OPTIONS)
        MAKECASE(OID_802_3_RCV_ERROR_ALIGNMENT)
        MAKECASE(OID_802_3_XMIT_ONE_COLLISION)
        MAKECASE(OID_802_3_XMIT_MORE_COLLISIONS)
        MAKECASE(OID_802_3_XMIT_DEFERRED)
        MAKECASE(OID_802_3_XMIT_MAX_COLLISIONS)
        MAKECASE(OID_802_3_RCV_OVERRUN)
        MAKECASE(OID_802_3_XMIT_UNDERRUN)
        MAKECASE(OID_802_3_XMIT_HEARTBEAT_FAILURE)
        MAKECASE(OID_802_3_XMIT_TIMES_CRS_LOST)
        MAKECASE(OID_802_3_XMIT_LATE_COLLISIONS)

        MAKECASE(MTK_OID_N6_QUERY_VENDOR)
        MAKECASE(MTK_OID_N6_QUERY_PHY_MODE)
        MAKECASE(MTK_OID_N6_SET_PHY_MODE)
        MAKECASE(MTK_OID_N6_QUERY_COUNTRY_REGION)
        MAKECASE(MTK_OID_N6_SET_COUNTRY_REGION)
        MAKECASE(MTK_OID_N6_QUERY_EEPROM_VERSION)
        MAKECASE(MTK_OID_N6_QUERY_FIRMWARE_VERSION)
        MAKECASE(MTK_OID_N6_QUERY_CURRENT_CHANNEL_ID)
        MAKECASE(MTK_OID_N6_QUERY_TX_POWER_LEVEL_1)
        MAKECASE(MTK_OID_N6_SET_TX_POWER_LEVEL_1)
        MAKECASE(MTK_OID_N6_QUERY_HARDWARE_REGISTER)
        MAKECASE(MTK_OID_N6_SET_HARDWARE_REGISTER)
        MAKECASE(MTK_OID_N6_QUERY_LINK_STATUS)
        MAKECASE(MTK_OID_N6_QUERY_NOISE_LEVEL)
        MAKECASE(MTK_OID_N6_QUERY_STATISTICS)
        MAKECASE(MTK_OID_N6_SET_RESET_COUNTERS)
        MAKECASE(MTK_OID_N6_QUERY_EXTRA_INFO)
        MAKECASE(MTK_OID_N6_QUERY_LAST_RX_RATE)
        MAKECASE(MTK_OID_N6_QUERY_RSSI_0)
        MAKECASE(MTK_OID_N6_QUERY_RSSI_1)
        MAKECASE(MTK_OID_N6_QUERY_BALD_EAGLE_SSID)
        MAKECASE(MTK_OID_N6_SET_BALD_EAGLE_SSID)
        MAKECASE(MTK_OID_N6_QUERY_LAST_TX_RATE)
        MAKECASE(MTK_OID_N6_QUERY_RSSI_2)
        MAKECASE(MTK_OID_N6_QUERY_SNR_0)
        MAKECASE(MTK_OID_N6_QUERY_SNR_1)
        MAKECASE(MTK_OID_N6_QUERY_CONFIGURATION)
        MAKECASE(MTK_OID_N6_SET_CONFIGURATION)
        MAKECASE(MTK_OID_N6_QUERY_AUTHENTICATION_MODE)
        MAKECASE(MTK_OID_N6_SET_AUTHENTICATION_MODE)
        MAKECASE(MTK_OID_N6_QUERY_ENCRYPTION_STATUS)
        MAKECASE(MTK_OID_N6_SET_ENCRYPTION_STATUS)
        MAKECASE(MTK_OID_N6_SET_REMOVE_KEY)
        MAKECASE(MTK_OID_N6_SET_ADD_KEY)
        MAKECASE(MTK_OID_N6_QUERY_EVENT_TABLE)
        MAKECASE(MTK_OID_N6_SET_ACL)
        MAKECASE(MTK_OID_N6_QUERY_OP_MODE)
        MAKECASE(MTK_OID_N6_SET_OP_MODE)
        MAKECASE(MTK_OID_N6_QUERY_AP_CONFIG)
        MAKECASE(MTK_OID_N6_SET_AP_CONFIG)
        MAKECASE(MTK_OID_N6_QUERY_BATABLE)
        MAKECASE(MTK_OID_N6_QUERY_IMME_BA_CAP)
        MAKECASE(MTK_OID_N6_SET_IMME_BA_CAP)
        MAKECASE(MTK_OID_N6_SET_ADD_IMME_BA)
        MAKECASE(MTK_OID_N6_SET_TEAR_IMME_BA)
        MAKECASE(MTK_OID_N6_QUERY_HT_PHYMODE)
        MAKECASE(MTK_OID_N6_SET_HT_PHYMODE)
        MAKECASE(MTK_OID_N6_QUERY_MAC_TABLE)
        MAKECASE(MTK_OID_N6_SET_DESIRED_BSSID_LIST)
        MAKECASE(MTK_OID_N6_SET_DISCONNECT_REQUEST)
        MAKECASE(MTK_OID_N6_QUERY_WPA_REKEY)
        MAKECASE(MTK_OID_N6_SET_WPA_REKEY)
        MAKECASE(MTK_OID_N6_SET_FLUSH_BSS_LIST)
        MAKECASE(MTK_OID_N6_QUERY_STA_CONFIG)
        MAKECASE(MTK_OID_N6_SET_STA_CONFIG)
        MAKECASE(MTK_OID_N6_SET_CCX20_INFO)
        MAKECASE(MTK_OID_N6_QUERY_PREAMBLE)
        MAKECASE(MTK_OID_N6_SET_PREAMBLE)
        MAKECASE(MTK_OID_N6_QUERY_APSD_SETTING)
        MAKECASE(MTK_OID_N6_SET_APSD_SETTING)
        MAKECASE(MTK_OID_N6_QUERY_APSD_PSM)
        MAKECASE(MTK_OID_N6_SET_APSD_PSM)
        MAKECASE(MTK_OID_N6_QUERY_WMM)
        MAKECASE(MTK_OID_N6_SET_WMM)
        MAKECASE(MTK_OID_N6_QUERY_DLS)
        MAKECASE(MTK_OID_N6_SET_DLS)
        MAKECASE(MTK_OID_N6_QUERY_DLS_PARAM)
        MAKECASE(MTK_OID_N6_SET_DLS_PARAM)
        MAKECASE(MTK_OID_N6_SET_FRAGMENTATION_THRESHOLD)
        MAKECASE(MTK_OID_N6_SET_RTS_THRESHOLD)
        MAKECASE(MTK_OID_N6_SET_POWER_MGMT_REQUEST)
        MAKECASE(MTK_OID_N6_QUERY_USB_VERSION)
        MAKECASE(MTK_OID_N6_SET_WSC_MODE)
        MAKECASE(MTK_OID_N6_SET_WSC_ASSOCIATE_IE)
        MAKECASE(MTK_OID_N6_SET_WSC_PROBEREQ_IE)
        MAKECASE(MTK_OID_N6_SET_WSC_CUSTOMIZED_IE_PARAM)
        MAKECASE(MTK_OID_N6_SET_WSC_PROFILE)
        MAKECASE(MTK_OID_N6_SET_WSC_ACTIVE_PROFILE)
        MAKECASE(MTK_OID_N6_SET_WSC_CUSTOMIZE_DEVINFO)
        MAKECASE(MTK_OID_N6_QUERY_WSC_STATUS)
        MAKECASE(MTK_OID_N6_QUERY_WSC_PROFILE)
        MAKECASE(MTK_OID_N6_QUERY_WSC_SSID)     
        MAKECASE(MTK_OID_N6_QUERY_WSC_HW_PBC)
        MAKECASE(MTK_OID_N6_SET_PREFERRED_WPS_AP_PHY_TYPE)
        MAKECASE(MTK_OID_N6_QUERY_PREFERRED_WPS_AP_PHY_TYPE)
        MAKECASE(MTK_OID_N6_QUERY_WSC_AP_CHANNEL)
        MAKECASE(MTK_OID_N6_QUERY_SNR_2)
        MAKECASE(MTK_OID_N6_QUERY_STBC_RX_COUNT)
        MAKECASE(MTK_OID_N6_QUERY_STBC_TX_COUNT)
        MAKECASE(MTK_OID_N6_QUERY_SS_NUM)
        MAKECASE(MTK_OID_N6_SET_SS_NUM)
        MAKECASE(MTK_OID_N6_SET_DISABLE_ANTENNA_DIVERSITY)
        MAKECASE(MTK_OID_N6_SET_FIXED_MAIN_ANTENNA)
        MAKECASE(MTK_OID_N6_SET_FIXED_AUX_ANTENNA)
        MAKECASE(MTK_OID_N6_QUERY_WTBL_INFO)
        MAKECASE(MTK_OID_N6_QUERY_TEST_TX_NULL_FRAME)
        MAKECASE(MTK_OID_N6_SET_TEST_TX_NULL_FRAME)
        MAKECASE(MTK_OID_N6_QUERY_RADIO_STATUS)
        MAKECASE(MTK_OID_N6_SET_RADIO)
        MAKECASE(MTK_OID_N6_QUERY_MIB)
        MAKECASE(MTK_OID_N6_QUERY_POWER_MANAGEMENT)
        MAKECASE(MTK_OID_N6_SET_POWER_MANAGEMENT)
#if(COMPILE_WIN8_ABOVE(CURRENT_OS_NDIS_VER))  
        // Wi-Fi Direct
        MAKECASE(OID_DOT11_WFD_DEVICE_CAPABILITY)
        MAKECASE(OID_DOT11_WFD_GROUP_OWNER_CAPABILITY)
        MAKECASE(OID_DOT11_WFD_DEVICE_INFO)
        MAKECASE(OID_DOT11_WFD_SECONDARY_DEVICE_TYPE_LIST)
        MAKECASE(OID_DOT11_WFD_ADDITIONAL_IE)
        MAKECASE(OID_DOT11_WFD_DISCOVER_REQUEST)
        MAKECASE(OID_DOT11_WFD_ENUM_DEVICE_LIST)
        MAKECASE(OID_DOT11_WFD_LISTEN_STATE_DISCOVERABILITY)
        MAKECASE(OID_DOT11_WFD_FLUSH_DEVICE_LIST)
        MAKECASE(OID_DOT11_WFD_SEND_GO_NEGOTIATION_REQUEST)
        MAKECASE(OID_DOT11_WFD_SEND_GO_NEGOTIATION_RESPONSE)
        MAKECASE(OID_DOT11_WFD_SEND_GO_NEGOTIATION_CONFIRMATION)
        MAKECASE(OID_DOT11_WFD_SEND_INVITATION_REQUEST)
        MAKECASE(OID_DOT11_WFD_SEND_INVITATION_RESPONSE)
        MAKECASE(OID_DOT11_WFD_SEND_PROVISION_DISCOVERY_REQUEST)
        MAKECASE(OID_DOT11_WFD_SEND_PROVISION_DISCOVERY_RESPONSE)
        MAKECASE(OID_DOT11_WFD_DESIRED_GROUP_ID)
        MAKECASE(OID_DOT11_WFD_START_GO_REQUEST)
        MAKECASE(OID_DOT11_WFD_CONNECT_TO_GROUP_REQUEST)
        MAKECASE(OID_DOT11_WFD_DISCONNECT_FROM_GROUP_REQUEST)
        MAKECASE(OID_DOT11_WFD_GROUP_START_PARAMETERS) 
        MAKECASE(OID_DOT11_WFD_GROUP_JOIN_PARAMETERS)
        MAKECASE(OID_DOT11_WFD_GET_DIALOG_TOKEN)
        MAKECASE(OID_DOT11_WFD_STOP_DISCOVERY)
        //MAKECASE(OID_DOT11_WFD_DEVICE_LISTEN_CHANNEL)

        //Power Management
        MAKECASE(OID_DOT11_POWER_MGMT_MODE_STATUS)
        MAKECASE(OID_DOT11_POWER_MGMT_MODE_AUTO_ENABLED)
//      MAKECASE(OID_DOT11_POWER_MGMT_AUTO_MODE_STATUS)
        MAKECASE(OID_DOT11_OFFLOAD_NETWORK_LIST)
#endif

        default:
            oidName = "<** UNKNOWN OID **>";
            break;
    }

    return oidName;
}
#endif

//
//      OPEN  OPEN0  SHARE  OPEN    SHARE   OPEN  SHARE  WPA   WPAPSK  WPA2  WPA2PSK  WPA  WPAPSK  WPA2  WPA2PSK
//      OPEN  WEP40  WEP40  WEP104  WEP104  WEP    WEP   TKIP   TKIP   TKIP   TKIP    AES    AES   AES     AES     Total
// BSS   V      V      V      V       V      V      V     V      V      V      V       V      V     V       V       15
//IBSS   V      V      X      V       X      V      X     X      X      X      X       X      X     X       V       5

DOT11_AUTH_CIPHER_PAIR   BSSUnicastAuthCipherPairs[]=
{
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_NONE},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP40},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP104},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP},

    {DOT11_AUTH_ALGO_80211_SHARED_KEY,  DOT11_CIPHER_ALGO_WEP40},
    {DOT11_AUTH_ALGO_80211_SHARED_KEY,  DOT11_CIPHER_ALGO_WEP104},
    {DOT11_AUTH_ALGO_80211_SHARED_KEY,  DOT11_CIPHER_ALGO_WEP},

    {DOT11_AUTH_ALGO_WPA,               DOT11_CIPHER_ALGO_TKIP},
    {DOT11_AUTH_ALGO_WPA,               DOT11_CIPHER_ALGO_CCMP},
    
    {DOT11_AUTH_ALGO_WPA_PSK,           DOT11_CIPHER_ALGO_TKIP},
    {DOT11_AUTH_ALGO_WPA_PSK,           DOT11_CIPHER_ALGO_CCMP},

    {DOT11_AUTH_ALGO_RSNA,              DOT11_CIPHER_ALGO_TKIP},
    {DOT11_AUTH_ALGO_RSNA,              DOT11_CIPHER_ALGO_CCMP},

    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_TKIP},
    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_CCMP},
};
USHORT uBSSUnicastAuthCipherPairsSize = sizeof(BSSUnicastAuthCipherPairs);

DOT11_AUTH_CIPHER_PAIR   IBSSUnicastAuthCipherPairs[] =
{
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_NONE},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP40},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP104},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP},

    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_CCMP},
};
USHORT uIBSSUnicastAuthCipherPairsSize = sizeof(IBSSUnicastAuthCipherPairs);

//
//             OPEN  SHARE  WPA  WPAPSK  WPA2  WPA2PSK 
//     OPEN     V 
//     WEP40    V      V     V     V      V      V
//     WEP104   V      V     V     V      V      V
//     WEP      V      V           
//     TKIP                  V     V      V      V
//     AES                   V     V      V      V
//   -----------------------------------------------------
// BSS          4      3     4     4      4      4
//
//             OPEN  WPA2PSK 
//     OPEN     V 
//     WEP40    V   
//     WEP104   V   
//     WEP      V   
//     TKIP                 
//     AES             V 
//   -----------------------------------------------------
//IBSS          4      1
//

DOT11_AUTH_CIPHER_PAIR BSSMulticastAuthCipherPairs[] = 
{
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_NONE},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP40},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP104},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP},

    {DOT11_AUTH_ALGO_80211_SHARED_KEY,  DOT11_CIPHER_ALGO_WEP40},
    {DOT11_AUTH_ALGO_80211_SHARED_KEY,  DOT11_CIPHER_ALGO_WEP104},
    {DOT11_AUTH_ALGO_80211_SHARED_KEY,  DOT11_CIPHER_ALGO_WEP},

    {DOT11_AUTH_ALGO_WPA,               DOT11_CIPHER_ALGO_WEP40},
    {DOT11_AUTH_ALGO_WPA,               DOT11_CIPHER_ALGO_WEP104},
    {DOT11_AUTH_ALGO_WPA,               DOT11_CIPHER_ALGO_TKIP},
    {DOT11_AUTH_ALGO_WPA,               DOT11_CIPHER_ALGO_CCMP},
    
    {DOT11_AUTH_ALGO_WPA_PSK,           DOT11_CIPHER_ALGO_WEP40},
    {DOT11_AUTH_ALGO_WPA_PSK,           DOT11_CIPHER_ALGO_WEP104},
    {DOT11_AUTH_ALGO_WPA_PSK,           DOT11_CIPHER_ALGO_TKIP},
    {DOT11_AUTH_ALGO_WPA_PSK,           DOT11_CIPHER_ALGO_CCMP},

    {DOT11_AUTH_ALGO_RSNA,              DOT11_CIPHER_ALGO_WEP40},
    {DOT11_AUTH_ALGO_RSNA,              DOT11_CIPHER_ALGO_WEP104},
    {DOT11_AUTH_ALGO_RSNA,              DOT11_CIPHER_ALGO_TKIP},
    {DOT11_AUTH_ALGO_RSNA,              DOT11_CIPHER_ALGO_CCMP},

    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_WEP40},
    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_WEP104},
    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_TKIP},
    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_CCMP},
};
USHORT uBSSMulticastAuthCipherPairsSize = sizeof(BSSMulticastAuthCipherPairs);
    
#if(COMPILE_WIN8_ABOVE(CURRENT_OS_NDIS_VER))  
DOT11_AUTH_CIPHER_PAIR BSSMulticastMgmtAuthCipherPairs[] = 
{
    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_BIP},
    {DOT11_AUTH_ALGO_RSNA,              DOT11_CIPHER_ALGO_BIP},
};
USHORT uBSSMulticastMgmtAuthCipherPairsSize = sizeof(BSSMulticastMgmtAuthCipherPairs);
#endif

DOT11_AUTH_CIPHER_PAIR IBSSMulticastAuthCipherPairs[] = 
{
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_NONE},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP40},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP104},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP},

    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_CCMP},
};
USHORT uIBSSMulticastAuthCipherPairsSize = sizeof(IBSSMulticastAuthCipherPairs);

//
// ExtAP auth/cipher algorithms
//
DOT11_AUTH_CIPHER_PAIR   ExtAPUnicastAuthCipherPairs[]=
{
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_NONE},

    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_TKIP},
    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_CCMP},
};
USHORT uExtAPUnicastAuthCipherPairsSize = sizeof(ExtAPUnicastAuthCipherPairs);

DOT11_AUTH_CIPHER_PAIR   ExtAPMulticastAuthCipherPairs[]=
{
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_NONE},

    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_TKIP},
    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_CCMP},
};
USHORT uExtAPMulticastAuthCipherPairsSize = sizeof(ExtAPMulticastAuthCipherPairs);

const DOT11_AUTH_CIPHER_PAIR VStationIBSSUnicastAuthCipherPairs[] =
{
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_NONE},
#if 1
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP40},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP104},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP},

    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_CCMP}
#endif
};

const DOT11_AUTH_CIPHER_PAIR VStationIBSSMulticastAuthCipherPairs[] = 
{
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_NONE},
#if 1
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP40},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP104},
    {DOT11_AUTH_ALGO_80211_OPEN,        DOT11_CIPHER_ALGO_WEP},

    {DOT11_AUTH_ALGO_RSNA_PSK,          DOT11_CIPHER_ALGO_CCMP}
#endif
};

NDIS_OID NICSupportedOids[] =
{
    //
    // Private OIDs
    //
    MTK_OID_LIST,

    //* CCX Event OID
    MTK_CCX_OID_LIST,
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_PHYSICAL_MEDIUM,
    OID_GEN_MAXIMUM_LOOKAHEAD,  
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_GEN_RCV_CRC_ERROR,
    OID_GEN_TRANSMIT_QUEUE_LENGTH,
    OID_802_3_PERMANENT_ADDRESS,
    OID_DOT11_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_DOT11_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_DOT11_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,
    OID_GEN_INTERRUPT_MODERATION,
    OID_GEN_LINK_PARAMETERS,
    OID_PM_PARAMETERS,

    // For Native Wi-Fi drivers these OIDs are handled by the Native Wi-Fi filter
    /*
    OID_GEN_STATISTICS,
    */

    // Miniport does not support Wakeup today
    /*
    OID_PNP_CAPABILITIES,
    OID_PNP_ADD_WAKE_UP_PATTERN,
    OID_PNP_REMOVE_WAKE_UP_PATTERN,
    OID_PNP_ENABLE_WAKE_UP,
    */

    //
    // 802.11 specific OIDs
    //
    OID_DOT11_MPDU_MAX_LENGTH,
    OID_DOT11_OPERATION_MODE_CAPABILITY,
    OID_DOT11_CURRENT_OPERATION_MODE,
    OID_DOT11_ATIM_WINDOW,
    OID_DOT11_SCAN_REQUEST,
    OID_DOT11_RESET_REQUEST,
    OID_DOT11_NIC_POWER_STATE,
    OID_DOT11_OPTIONAL_CAPABILITY,
    OID_DOT11_CURRENT_OPTIONAL_CAPABILITY,
    OID_DOT11_STATION_ID,
    OID_DOT11_CF_POLLABLE,
    OID_DOT11_CHANNEL_AGILITY_ENABLED,  // PHY: dot11ChannelAgilityEnabled 
    OID_DOT11_CHANNEL_AGILITY_PRESENT,  // PHY: dot11ChannelAgilityPresent     
    OID_DOT11_OPERATIONAL_RATE_SET,
    OID_DOT11_BEACON_PERIOD,
    OID_DOT11_MAC_ADDRESS,
    OID_DOT11_RTS_THRESHOLD,
    OID_DOT11_SHORT_RETRY_LIMIT,
    OID_DOT11_LONG_RETRY_LIMIT,
    OID_DOT11_FRAGMENTATION_THRESHOLD,
    OID_DOT11_MAX_TRANSMIT_MSDU_LIFETIME,
    OID_DOT11_MAX_RECEIVE_LIFETIME,
    OID_DOT11_SUPPORTED_PHY_TYPES,
    OID_DOT11_CURRENT_REG_DOMAIN,
    OID_DOT11_TEMP_TYPE,
    // OID_DOT11_CURRENT_TX_ANTENNA,
    OID_DOT11_DIVERSITY_SUPPORT,
    // OID_DOT11_CURRENT_RX_ANTENNA,
    OID_DOT11_SUPPORTED_POWER_LEVELS,
    OID_DOT11_CURRENT_TX_POWER_LEVEL,
    OID_DOT11_CURRENT_CHANNEL,
    OID_DOT11_CCA_MODE_SUPPORTED,
    OID_DOT11_CURRENT_CCA_MODE,
    OID_DOT11_ED_THRESHOLD,
    OID_DOT11_REG_DOMAINS_SUPPORT_VALUE,
    OID_DOT11_SUPPORTED_TX_ANTENNA,
    OID_DOT11_SUPPORTED_RX_ANTENNA,
    OID_DOT11_DIVERSITY_SELECTION_RX,
    OID_DOT11_SUPPORTED_DATA_RATES_VALUE,
    OID_DOT11_RF_USAGE,
    OID_DOT11_RECV_SENSITIVITY_LIST,
    OID_DOT11_MULTI_DOMAIN_CAPABILITY_IMPLEMENTED,
    OID_DOT11_MULTI_DOMAIN_CAPABILITY_ENABLED,
    OID_DOT11_COUNTRY_STRING,
    OID_DOT11_CURRENT_FREQUENCY,
    OID_DOT11_FREQUENCY_BANDS_SUPPORTED,
    OID_DOT11_SHORT_PREAMBLE_OPTION_IMPLEMENTED,
    OID_DOT11_PBCC_OPTION_IMPLEMENTED,
    OID_DOT11_ERP_PBCC_OPTION_IMPLEMENTED,
    OID_DOT11_ERP_PBCC_OPTION_ENABLED,
    OID_DOT11_DSSS_OFDM_OPTION_IMPLEMENTED,
    OID_DOT11_DSSS_OFDM_OPTION_ENABLED,
    OID_DOT11_SHORT_SLOT_TIME_OPTION_IMPLEMENTED,
    OID_DOT11_SHORT_SLOT_TIME_OPTION_ENABLED,

    OID_DOT11_ENUM_BSS_LIST,
    OID_DOT11_FLUSH_BSS_LIST,
    OID_DOT11_POWER_MGMT_REQUEST,
    OID_DOT11_DESIRED_SSID_LIST,
    OID_DOT11_EXCLUDED_MAC_ADDRESS_LIST,
    OID_DOT11_EXCLUDE_UNENCRYPTED,
    OID_DOT11_DESIRED_BSSID_LIST,
    OID_DOT11_DESIRED_BSS_TYPE,
    OID_DOT11_CONNECT_REQUEST,
    OID_DOT11_STATISTICS,
    OID_DOT11_ENABLED_AUTHENTICATION_ALGORITHM,
    OID_DOT11_SUPPORTED_UNICAST_ALGORITHM_PAIR,
    OID_DOT11_SUPPORTED_MULTICAST_ALGORITHM_PAIR,
    OID_DOT11_ENABLED_UNICAST_CIPHER_ALGORITHM,
    OID_DOT11_ENABLED_MULTICAST_CIPHER_ALGORITHM,   
    OID_DOT11_CIPHER_DEFAULT_KEY_ID,
    OID_DOT11_CIPHER_DEFAULT_KEY,
    OID_DOT11_CIPHER_KEY_MAPPING_KEY,
    OID_DOT11_ENUM_ASSOCIATION_INFO,
    OID_DOT11_DISCONNECT_REQUEST,
    OID_DOT11_HARDWARE_PHY_STATE,
    OID_DOT11_DESIRED_PHY_LIST,
    OID_DOT11_CURRENT_PHY_ID,
    OID_DOT11_MEDIA_STREAMING_ENABLED,
    OID_DOT11_UNREACHABLE_DETECTION_THRESHOLD,
    OID_DOT11_ACTIVE_PHY_LIST,
    OID_DOT11_EXTSTA_CAPABILITY,
    OID_DOT11_DATA_RATE_MAPPING_TABLE,
    OID_DOT11_MAXIMUM_LIST_SIZE,
    OID_DOT11_PRIVACY_EXEMPTION_LIST,
    OID_DOT11_IBSS_PARAMS,
    OID_DOT11_PMKID_LIST,
    OID_DOT11_AUTO_CONFIG_ENABLED,
    OID_DOT11_UNICAST_USE_GROUP_ENABLED,
    OID_DOT11_SAFE_MODE_ENABLED,
    OID_DOT11_HIDDEN_NETWORK_ENABLED,
    OID_DOT11_QOS_PARAMS    ,
    OID_DOT11_ASSOCIATION_PARAMS,
    // ExtAP specific OIDs
    OID_DOT11_DTIM_PERIOD,                      // dot11DTIMPeriod
    OID_DOT11_AVAILABLE_CHANNEL_LIST,           // msDot11AvailableChannelList
    OID_DOT11_AVAILABLE_FREQUENCY_LIST,         // msDot11AvailableFrequencyList
    OID_DOT11_ENUM_PEER_INFO,                   
    OID_DOT11_DISASSOCIATE_PEER_REQUEST,        
    OID_DOT11_PORT_STATE_NOTIFICATION,
    OID_DOT11_INCOMING_ASSOCIATION_DECISION,
    OID_DOT11_ADDITIONAL_IE,
    OID_DOT11_WPS_ENABLED,
    OID_DOT11_START_AP_REQUEST, 

    // Virtual WiFi specifc OIDs
    OID_DOT11_CREATE_MAC,
    OID_DOT11_DELETE_MAC,    
    OID_DOT11_VIRTUAL_STATION_CAPABILITY,

#if(COMPILE_WIN8_ABOVE(CURRENT_OS_NDIS_VER))  
    // Win8 Wi-Fi Direct
    OID_DOT11_WFD_DEVICE_CAPABILITY,
    OID_DOT11_WFD_GROUP_OWNER_CAPABILITY ,
    OID_DOT11_WFD_DEVICE_INFO,
    OID_DOT11_WFD_SECONDARY_DEVICE_TYPE_LIST,
    OID_DOT11_WFD_ADDITIONAL_IE,
    OID_DOT11_WFD_DISCOVER_REQUEST,
    OID_DOT11_WFD_ENUM_DEVICE_LIST,
    OID_DOT11_WFD_LISTEN_STATE_DISCOVERABILITY,
    OID_DOT11_WFD_FLUSH_DEVICE_LIST,
    OID_DOT11_WFD_SEND_GO_NEGOTIATION_REQUEST,
    OID_DOT11_WFD_SEND_GO_NEGOTIATION_RESPONSE,
    OID_DOT11_WFD_SEND_GO_NEGOTIATION_CONFIRMATION,
    OID_DOT11_WFD_SEND_INVITATION_REQUEST,
    OID_DOT11_WFD_SEND_INVITATION_RESPONSE,
    OID_DOT11_WFD_SEND_PROVISION_DISCOVERY_REQUEST,
    OID_DOT11_WFD_SEND_PROVISION_DISCOVERY_RESPONSE,
    OID_DOT11_WFD_DESIRED_GROUP_ID,
    OID_DOT11_WFD_START_GO_REQUEST,
    OID_DOT11_WFD_CONNECT_TO_GROUP_REQUEST,
    OID_DOT11_WFD_DISCONNECT_FROM_GROUP_REQUEST,
    OID_DOT11_WFD_GROUP_START_PARAMETERS,
    OID_DOT11_WFD_GROUP_JOIN_PARAMETERS,
    OID_DOT11_WFD_GET_DIALOG_TOKEN,
    OID_DOT11_WFD_STOP_DISCOVERY,
    //OID_DOT11_WFD_DEVICE_LISTEN_CHANNEL,

    // Power Management
    OID_DOT11_POWER_MGMT_MODE_STATUS,
    OID_DOT11_POWER_MGMT_MODE_AUTO_ENABLED,
//  OID_DOT11_POWER_MGMT_AUTO_MODE_STATUS,

    OID_DOT11_OFFLOAD_NETWORK_LIST,
#if _WIN8_USB_SS_SUPPORTED
    //USB Selective Suspend
#if 0 // mark it for a temp. ntddndis.h didn't support those OID yet.
    OID_POWER_SUSPEND,
    OID_POWER_RESUME,
#endif
#endif

#endif //NDIS630_MINIPORT
};

ULONG   NIC_SUPPORT_OID_SIZE = sizeof(NICSupportedOids);

/*
    ========================================================================
    
    Routine Description:
        Allocate MP_ADAPTER data block and do some initialization

    Arguments:
        Adapter     Pointer to our adapter

    Return Value:
        NDIS_STATUS_SUCCESS
        NDIS_STATUS_FAILURE

    IRQL = PASSIVE_LEVEL

    Note:
    
    ========================================================================
*/
NDIS_STATUS Ndis6CommonAllocAdapterBlock(
    IN NDIS_HANDLE MiniportAdapterHandle,
    OUT PMP_ADAPTER   *ppAd)
{
    PMP_ADAPTER   pAd;
    NDIS_STATUS     ndisStatus = NDIS_STATUS_SUCCESS;
    ULONG                   size;

    DBGPRINT(RT_DEBUG_TRACE, ("--> Ndis6CommonAllocAdapterBlock\n"));

    *ppAd = NULL;

    do
    {
        // Allocate MP_ADAPTER memory block

        pAd = (PMP_ADAPTER)NdisAllocateMemoryWithTagPriority( MiniportAdapterHandle, 
                                                                                            sizeof(MP_ADAPTER), 
                                                                                            NIC_TAG,
                                                                                            NormalPoolPriority);



        if (pAd == NULL)
        {
            DBGPRINT(RT_DEBUG_ERROR, ("Failed to allocate memory - ADAPTER\n"));
            ndisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        G_MemoryAllocate_cnt++;
        G_MemoryAllocate_Len+= sizeof(MP_ADAPTER);

        // Clean up the memory block
        PlatformZeroMemory(pAd, sizeof(MP_ADAPTER));

        //
        // Dynamic memory allocation for pP2pCtrll
        //
        pAd->pP2pCtrll = (PP2P_CTRL_T) NdisAllocateMemoryWithTagPriority(MiniportAdapterHandle,
                                                                       sizeof(P2P_CTRL_T),
                                                                       NIC_TAG,
                                                                       NormalPoolPriority);

        if (pAd->pP2pCtrll == NULL)
        {
            DBGPRINT_ERR(("Failed to allocate memory - pP2pCtrll\n"));
            ndisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        PlatformZeroMemory(pAd->pP2pCtrll, sizeof(P2P_CTRL_T));
        G_MemoryAllocate_cnt ++;
        G_MemoryAllocate_Len += sizeof(P2P_CTRL_T);

        //
        // Dynamic memory allocation for pRxCfg
        //
        pAd->pRxCfg = (PRX_CONFIG) NdisAllocateMemoryWithTagPriority(MiniportAdapterHandle,
                                                                       sizeof(RX_CONFIG),
                                                                       NIC_TAG,
                                                                       NormalPoolPriority);

        if (pAd->pRxCfg == NULL)
        {
            DBGPRINT_ERR(("Failed to allocate memory - pRxCfg\n"));
            ndisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        PlatformZeroMemory(pAd->pRxCfg, sizeof(RX_CONFIG));
        G_MemoryAllocate_cnt ++;
        G_MemoryAllocate_Len += sizeof(RX_CONFIG);


        //
        // Dynamic memory allocation for pTxCfg
        //
        pAd->pTxCfg = (PTX_CONFIG) NdisAllocateMemoryWithTagPriority(MiniportAdapterHandle,
                                                                       sizeof(TX_CONFIG),
                                                                       NIC_TAG,
                                                                       NormalPoolPriority);

        if (pAd->pTxCfg == NULL)
        {
            DBGPRINT_ERR(("Failed to allocate memory - pTxCfg\n"));
            ndisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        PlatformZeroMemory(pAd->pTxCfg, sizeof(TX_CONFIG));
        G_MemoryAllocate_cnt ++;
        G_MemoryAllocate_Len += sizeof(TX_CONFIG);

        //
        // Dynamic memory allocation for pHifCfg
        //
        pAd->pHifCfg = (PHIF_CONFIG) NdisAllocateMemoryWithTagPriority(MiniportAdapterHandle,
                                                                       sizeof(HIF_CONFIG),
                                                                       NIC_TAG,
                                                                       NormalPoolPriority);

        if (pAd->pHifCfg == NULL)
        {
            DBGPRINT_ERR(("Failed to allocate memory - pHifCfg\n"));
            ndisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        PlatformZeroMemory(pAd->pHifCfg, sizeof(HIF_CONFIG));
        G_MemoryAllocate_cnt ++;
        G_MemoryAllocate_Len += sizeof(HIF_CONFIG);

        //
        // Dynamic memory allocation for pNicCfg
        //
        pAd->pNicCfg = (PNIC_CONFIG) NdisAllocateMemoryWithTagPriority(MiniportAdapterHandle,
                                                                       sizeof(NIC_CONFIG),
                                                                       NIC_TAG,
                                                                       NormalPoolPriority);

        if (pAd->pNicCfg == NULL)
        {
            DBGPRINT_ERR(("Failed to allocate memory - pNicCfg\n"));
            ndisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        PlatformZeroMemory(pAd->pNicCfg, sizeof(NIC_CONFIG));
        G_MemoryAllocate_cnt ++;
        G_MemoryAllocate_Len += sizeof(NIC_CONFIG);
        
         //Alloc support phy type array
        pAd->StaCfg.pSupportedPhyTypes = NULL;
        size = sizeof(DOT11_SUPPORTED_PHY_TYPES) + (MAX_NUM_PHY_TYPES - 1) * sizeof(DOT11_PHY_TYPE);
        pAd->StaCfg.SupportedPhyTypesLen = size;
        PlatformAllocateMemory(pAd, (PVOID *)&pAd->StaCfg.pSupportedPhyTypes, size); 
        if ( pAd->StaCfg.pSupportedPhyTypes == NULL)
        {
            DBGPRINT(RT_DEBUG_ERROR, ("Allocate pSupportedPhyTypes failed\n"));
            return NDIS_STATUS_RESOURCES;
        }
        PlatformZeroMemory(pAd->StaCfg.pSupportedPhyTypes, size);
        
    } while (FALSE);

    *ppAd = pAd;    
    
    DBGPRINT(RT_DEBUG_TRACE, ("<-- Ndis6CommonAllocAdapterBlock, Status=%x\n", ndisStatus));

    return ndisStatus;
}

VOID
Ndis6CommonFillReceiveContext(
    IN  PMP_ADAPTER  pAd,
    IN  PMP_PORT      pPort,
    IN OUT PDOT11_EXTSTA_RECV_CONTEXT Dot11RecvContext,
    IN ULONGLONG TimeStamp)
{
    //
    // Fill in the send context fields that are always needed
    //
    MP_ASSIGN_NDIS_OBJECT_HEADER(Dot11RecvContext->Header, 
                                 NDIS_OBJECT_TYPE_DEFAULT,
                                 DOT11_EXTSTA_RECV_CONTEXT_REVISION_1,
                                 sizeof(DOT11_EXTSTA_RECV_CONTEXT));

    if ( pPort->PortCfg.OperationMode == DOT11_OPERATION_MODE_NETWORK_MONITOR)
    {
        Dot11RecvContext->uReceiveFlags |= DOT11_RECV_FLAG_RAW_PACKET;      
    }
    else
    {
        Dot11RecvContext->uReceiveFlags = 0; 
    }
    Dot11RecvContext->uPhyId = pPort->CommonCfg.SelectedPhyId;    
    Dot11RecvContext->uChCenterFrequency = pPort->Channel;
    Dot11RecvContext->usNumberOfMPDUsReceived = 1;

    //
    // For WlanQueryInterface(wlan_intf_opcode_rssi)
    //
    if ((pAd->HwCfg.BLNAGain != 0xFF) && (pAd->HwCfg.Antenna.field.RssiIndicationMode == USER_AWARENESS_MODE))
    {
        Dot11RecvContext->lRSSI = pAd->StaCfg.RssiSample.LastRssi[0] + GET_LNA_GAIN(pAd); // RSSI indication by Rx LNA output
    }
    else if (P2P_ON(pPort) && (pPort->PortSubtype == PORTSUBTYPE_P2PGO))
    {
        Dot11RecvContext->lRSSI = pPort->SoftAP.ApCfg.RssiSample.LastRssi[0]; 
    }
    else
    {
        Dot11RecvContext->lRSSI = pAd->StaCfg.RssiSample.LastRssi[0]; 
    }
    
    //
    // The value of ucDataRate is the value of the ucDataRateIndex member of the data rate from the 802.11 
    // station��s data rate mapping table. For more information about the data rate mapping table, 
    // see OID_DOT11_DATA_RATE_MAPPING_TABLE. 
    // 
    Dot11RecvContext->ucDataRate  = 7;

    //
    // This member is currently reserved for future use and must contain zero.
    // 
    Dot11RecvContext->uSizeMediaSpecificInfo = 0;

    // update timestamp
    if (TimeStamp != 0)
    {
        Dot11RecvContext->uReceiveFlags |= DOT11_RECV_FLAG_RAW_PACKET_TIMESTAMP;
        Dot11RecvContext->ullTimestamp = TimeStamp;
    }
}

VOID  Ndis6CommonPortFreeVariableIE(
    IN PMP_PORT pPort)
{
    if ((pPort == NULL) || (pPort->bActive == FALSE))
        return;
    
    // Reset Additional Beacon IE data
    if (pPort->PortCfg.AdditionalBeaconIEData)
    {
        PlatformFreeMemory(pPort->PortCfg.AdditionalBeaconIEData, pPort->PortCfg.AdditionalBeaconIESize);
        pPort->PortCfg.AdditionalBeaconIEData = NULL;
        DBGPRINT_RAW(RT_DEBUG_TRACE, ("===> %s : Beacon (port=%d) \n", __FUNCTION__, pPort->PortNumber));
    }
    pPort->PortCfg.AdditionalBeaconIESize = 0;

    // Reset Additional Probe Response IE data
    if (pPort->PortCfg.AdditionalResponseIEData)
    {
        PlatformFreeMemory(pPort->PortCfg.AdditionalResponseIEData, pPort->PortCfg.AdditionalResponseIESize);
        pPort->PortCfg.AdditionalResponseIEData = NULL;
        DBGPRINT_RAW(RT_DEBUG_TRACE, ("===> %s : Probe Respnse (port=%d) \n", __FUNCTION__, pPort->PortNumber));
    }
    pPort->PortCfg.AdditionalResponseIESize = 0;


    // Reset Additional Probe Request IE data
    if (pPort->PortCfg.AdditionalRequestIEData)
    {
        DBGPRINT(RT_DEBUG_TRACE, ("Free Additional Request IE Data memory...\n"));
        PlatformFreeMemory(pPort->PortCfg.AdditionalRequestIEData, pPort->PortCfg.AdditionalRequestIESize);
        pPort->PortCfg.AdditionalRequestIEData = NULL;
    }
    pPort->PortCfg.AdditionalRequestIESize = 0;

    // Reset P2P Additional Probe Request IE data
    if (pPort->PortCfg.P2PAdditionalRequestIEData)
    {
        PlatformFreeMemory(pPort->PortCfg.P2PAdditionalRequestIEData, pPort->PortCfg.P2PAdditionalRequestIESize);
        pPort->PortCfg.P2PAdditionalRequestIEData = NULL;
        DBGPRINT_RAW(RT_DEBUG_TRACE, ("===> %s : Probe Request (port=%d) \n", __FUNCTION__, pPort->PortNumber));        
    }
    pPort->PortCfg.P2PAdditionalRequestIESize = 0;

    // Reset Additional Assoc Request IE data
    if (pPort->PortCfg.AdditionalAssocReqIEData)
    {
        PlatformFreeMemory(pPort->PortCfg.AdditionalAssocReqIEData,  pPort->PortCfg.AdditionalAssocReqIESize);
        pPort->PortCfg.AdditionalAssocReqIEData = NULL;
        PlatformZeroMemory(pPort->PortCfg.AssocIEBSSID, DOT11_ADDRESS_SIZE);
        DBGPRINT_RAW(RT_DEBUG_TRACE, ("===> %s : Assoc Request (port=%d) \n", __FUNCTION__, pPort->PortNumber));
    }
    pPort->PortCfg.AdditionalAssocReqIESize = 0;

    // Reset Additional Assoc Response IE data
    if (pPort->PortCfg.AdditionalAssocRspIEData)
    {
        PlatformFreeMemory(pPort->PortCfg.AdditionalAssocRspIEData, pPort->PortCfg.AdditionalAssocRspIESize);
        pPort->PortCfg.AdditionalAssocRspIEData = NULL;
        DBGPRINT_RAW(RT_DEBUG_TRACE, ("===> %s : Assoc Response (port=%d) \n", __FUNCTION__, pPort->PortNumber));       
    }
    pPort->PortCfg.AdditionalAssocRspIESize= 0;
    
}

VOID Ndis6CommonPortFreePrivacyExemptionList(
    IN PMP_PORT pPort)
{
    if ((pPort == NULL) || (pPort->bActive == FALSE))
        return;

    if (pPort->PortCfg.PrivacyExemptionList != NULL)
    {
        PlatformFreeMemory(pPort->PortCfg.PrivacyExemptionList, pPort->PortCfg.PrivacyExemptionListLen);
        pPort->PortCfg.PrivacyExemptionList = NULL;
        pPort->PortCfg.PrivacyExemptionListLen = 0;

        DBGPRINT_RAW(RT_DEBUG_TRACE, ("===> %s (port=%d) \n", __FUNCTION__, pPort->PortNumber));
    }
}

/*
    ========================================================================
    
    Routine Description:

    Arguments:

    Return Value:

    IRQL = 
    
    Note:
    
    ========================================================================
*/
VOID    
Ndis6CommonRejectPendingPackets(
    IN  PMP_ADAPTER   pAd
    )
{
    UCHAR           Index;
    PQUEUE_ENTRY    pEntry;
    PQUEUE_HEADER   pQueue;
    MP_RW_LOCK_STATE PsQLockState;
    PMAC_TABLE_ENTRY pMacEntry = NULL;
    PMAC_TABLE_ENTRY pNextMacEntry = NULL;
    PQUEUE_HEADER pHeader;
    PMP_PORT pPort = pAd->PortList[FXXK_PORT_0];
    PMT_XMIT_CTRL_UNIT pXcu = NULL;
    
    DBGPRINT_RAW(RT_DEBUG_TRACE, ("--->RejectPendingPackets,  Pending[P=%d, Q1=%d,Q2=%d,Q3=%d,Q4=%d,McstPsQ=%d], pAd->Flags=0x%08x\n", 
            pAd->pTxCfg->NumQueuePacket,
            pAd->pTxCfg->SendTxWaitQueue[0].Number, pAd->pTxCfg->SendTxWaitQueue[1].Number, pAd->pTxCfg->SendTxWaitQueue[2].Number, 
            pAd->pTxCfg->SendTxWaitQueue[3].Number, pPort->MacTab.McastPsQueue.Number, pAd->Flags));

    DBGPRINT_RAW(RT_DEBUG_TRACE, ("--->RejectPendingPackets,  Pending XcuIdelQueue Number %d\n", pAd->pTxCfg->XcuIdelQueue.Number));

    for (Index = 0; Index < 4; Index++)
    {
        NdisAcquireSpinLock(&pAd->pTxCfg->SendTxWaitQueueLock[Index]);
        while (pAd->pTxCfg->SendTxWaitQueue[Index].Head != NULL)
        {
            pQueue = (PQUEUE_HEADER) &(pAd->pTxCfg->SendTxWaitQueue[Index]);
            pEntry = RemoveHeadQueue(pQueue);
            NdisReleaseSpinLock(&pAd->pTxCfg->SendTxWaitQueueLock[Index]);

            // Retrieve Ndis NET BUFFER pointer from MiniportReserved field
            pXcu = (PMT_XMIT_CTRL_UNIT)pEntry;

            if (pAd->NextDevicePowerState == NdisDeviceStateD3)
            {
                if((pXcu != NULL) && (pXcu->Reserve1 != NULL) && (pXcu->Reserve2 != NULL))
                {
                    RELEASE_NDIS_NETBUFFER(pAd, pXcu, NDIS_STATUS_LOW_POWER_STATE);
                }
            }
            else
            {
                if((pXcu != NULL) && (pXcu->Reserve1 != NULL) && (pXcu->Reserve2 != NULL))
                {
                    RELEASE_NDIS_NETBUFFER(pAd, pXcu, NDIS_STATUS_FAILURE);
                }
            }

            NdisAcquireSpinLock(&pAd->pTxCfg->SendTxWaitQueueLock[Index]);
        }
        NdisReleaseSpinLock(&pAd->pTxCfg->SendTxWaitQueueLock[Index]);
    }

    //NdisAcquireSpinLock(&pAd->MacTablePool.MacTabPoolLock);
    PlatformAcquireOldRWLockForWrite(&pAd->pTxCfg->PsQueueLock,&PsQLockState);
    while (pPort->MacTab.McastPsQueue.Head != NULL)
    {
        pQueue = (PQUEUE_HEADER) &pPort->MacTab.McastPsQueue;
        pEntry = RemoveHeadQueue(pQueue);
        pXcu = (PMT_XMIT_CTRL_UNIT)pEntry;

        if (pAd->NextDevicePowerState == NdisDeviceStateD3)
        {
            if((pXcu != NULL) && (pXcu->Reserve1 != NULL) && (pXcu->Reserve2 != NULL))
            {
                RELEASE_NDIS_NETBUFFER(pAd, pXcu, NDIS_STATUS_LOW_POWER_STATE);
            }
        }
        else
        {
            if((pXcu != NULL) && (pXcu->Reserve1 != NULL) && (pXcu->Reserve2 != NULL))
            {
                RELEASE_NDIS_NETBUFFER(pAd, pXcu, NDIS_STATUS_FAILURE);
            }
        }
    }

    pHeader = &pPort->MacTab.MacTabList;
    pNextMacEntry = (PMAC_TABLE_ENTRY)(pHeader->Head);
    while (pNextMacEntry != NULL)
    {
        pMacEntry = (PMAC_TABLE_ENTRY)pNextMacEntry;
        
        if(pMacEntry == NULL)
        {
            break; 
        }
        
        if (pMacEntry->ValidAsCLI == TRUE)
        {
            APCleanupPsQueue(pAd, &pMacEntry->PsQueue);     
        }
#if UAPSD_AP_SUPPORT
        NdisAcquireSpinLock(&pAd->UAPSD.UAPSDEOSPLock);
        ApUapsdCleanupUapsdQueue(pAd, pMacEntry, TRUE);
        NdisReleaseSpinLock(&pAd->UAPSD.UAPSDEOSPLock);           
#endif
        pNextMacEntry = pNextMacEntry->Next;   
        pMacEntry = NULL;
    }   
    
    PlatformReleaseOldRWLock(&pAd->pTxCfg->PsQueueLock,&PsQLockState);
    //NdisReleaseSpinLock(&pAd->MacTablePool.MacTabPoolLock);
    
    DBGPRINT_RAW(RT_DEBUG_TRACE, ("<---RejectPendingPackets,  mlme num= %d\n",pAd->Mlme.Queue.Num));

    
    DBGPRINT_RAW(RT_DEBUG_TRACE, ("<---RejectPendingPackets,  Pending[Q1=%d,Q2=%d,Q3=%d,Q4=%d,McstPsQ=%d], pAd->Flags=0x%08x\n", 
        pAd->pTxCfg->SendTxWaitQueue[0].Number, pAd->pTxCfg->SendTxWaitQueue[1].Number, pAd->pTxCfg->SendTxWaitQueue[2].Number, 
        pAd->pTxCfg->SendTxWaitQueue[3].Number, pPort->MacTab.McastPsQueue.Number, pAd->Flags));

    DBGPRINT_RAW(RT_DEBUG_TRACE, ("<---RejectPendingPackets,  Pending XcuIdelQueue Number %d\n", pAd->pTxCfg->XcuIdelQueue.Number));

        
}

VOID
Ndis6CommonFreePortData(
    IN  PMP_ADAPTER   pAd
    )
{
    UINT i=0;
    PMP_PORT pPort;
    
    for (i = 0; i < RTMP_MAX_NUMBER_OF_PORT; i++)
    {
        pPort = pAd->PortList[i];

        if ((pPort == NULL) || (pPort->bActive == FALSE))
            continue;

        // Clear Additional IE data by each port.
        Ndis6CommonPortFreeVariableIE(pPort);
        // Clear PrivacyExemptionList data by each port.
        Ndis6CommonPortFreePrivacyExemptionList(pPort);

        MlmePortFreeTimer(pAd, pPort);

#if(COMPILE_WIN8_ABOVE(CURRENT_OS_NDIS_VER))  
        if(NDIS_WIN8_ABOVE(pAd))
        {
            // Free WFDSecondaryDeviceTypeList
            P2pMsFreeIeMemory(&pPort->PortCfg.pWFDSecondaryDeviceTypeList,  &pPort->PortCfg.WFDNumOfSecondaryDevice);
        }
#endif  
    }
}


PMT_XMIT_CTRL_UNIT 
Ndis6CommonAllocateNdisNetBufferList(
    IN  PMP_ADAPTER       pAd,
    IN  ULONG                PortNumber,
    IN  PUCHAR              pHeader,
    IN  ULONG               DataLen
    )
{
    PNET_BUFFER     NetBuffer;
    PMP_LOCAL_RX_PKTS pLocalNetBufferList = NULL;
    PQUEUE_HEADER   pQueue;
    PMT_XMIT_CTRL_UNIT pXcu = NULL;
    NDIS_STATUS NdisStatus = NDIS_STATUS_SUCCESS;

    if (DataLen > MAX_FRAME_SIZE)
    {
        DBGPRINT(RT_DEBUG_ERROR, ("Ndis6CommonAllocateNdisNetBufferList, buffer overflow, Local buffer only allocate %d, but need Size=%d\n",
                            MAX_FRAME_SIZE, DataLen));
        NdisStatus = NDIS_STATUS_FAILURE;                 
        return NULL;
    }

    NdisAcquireSpinLock(&pAd->pTxCfg->LocalNetBufferListQueueLock);
    pQueue = (PQUEUE_HEADER) &pAd->pTxCfg->LocalNetBufferListQueue;
    if (pQueue->Head != NULL)
        pLocalNetBufferList = (PMP_LOCAL_RX_PKTS)RemoveHeadQueue(pQueue);
    NdisReleaseSpinLock(&pAd->pTxCfg->LocalNetBufferListQueueLock);

    if (pLocalNetBufferList == NULL)
    {
        DBGPRINT(RT_DEBUG_ERROR, ("Ndis6CommonAllocateNdisNetBufferList failed!\n"));
        NdisStatus = NDIS_STATUS_FAILURE;                 
        return NULL;
    }
    
    PlatformMoveMemory(pLocalNetBufferList->Data, pHeader, DataLen);

    NetBuffer = NET_BUFFER_LIST_FIRST_NB(pLocalNetBufferList->NetBufferList);
    MT_SET_NETBUFFER_SOURCE(NetBuffer, 0);
    MT_SET_NETBUFFER_LIST(NetBuffer, pLocalNetBufferList->NetBufferList);

    NET_BUFFER_DATA_LENGTH(NetBuffer) = DataLen;

    MmInitializeMdl(pLocalNetBufferList->Mdl, pLocalNetBufferList->Data, DataLen);
    MmBuildMdlForNonPagedPool(pLocalNetBufferList->Mdl);

    NdisAdjustMdlLength(pLocalNetBufferList->Mdl, DataLen); 

    NET_BUFFER_LIST_NEXT_NBL(pLocalNetBufferList->NetBufferList) = NULL;
    
    MT_SET_NETBUFFERLIST_IN_NBL(pLocalNetBufferList->NetBufferList, pLocalNetBufferList); 

    NdisAcquireSpinLock(&pAd->pTxCfg->XcuIdelQueueLock);
    pXcu = (PMT_XMIT_CTRL_UNIT)RemoveHeadQueue(&pAd->pTxCfg->XcuIdelQueue);

    NdisStatus = N6XmitGetTxbufToXcu(pAd, PortNumber, pLocalNetBufferList->NetBufferList, pLocalNetBufferList->NetBuffer, pXcu);

    if(NdisStatus != NDIS_STATUS_SUCCESS)
    {
        if(pXcu != NULL)
        {
            InsertTailQueue(&pAd->pTxCfg->XcuIdelQueue, pXcu);            
        }
    }
    NdisReleaseSpinLock(&pAd->pTxCfg->XcuIdelQueueLock);
    return pXcu;
}

NDIS_STATUS 
Ndis6CommonPortDeferOidRequest(
    IN PMP_ADAPTER pAd,
    IN PMP_PORT pPort,
    IN PNDIS_OID_REQUEST pNdisOidRequest,
    IN NDIS_IO_WORKITEM_FUNCTION DeferredCallback
    )
{
    //
    // Save the deferred OID request
    //
    pPort->DeferredOidRequest = pNdisOidRequest;

    // 
    // Queue the workitem
    //
    NdisQueueIoWorkItem(
        pPort->OidWorkItem,
        DeferredCallback,
        pPort);

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS 
Ndis6CommonPortCreateMac(
    IN PMP_ADAPTER pAd,
    IN PMP_PORT pPort,
    IN PNDIS_OID_REQUEST pNdisOidRequest
    )
{
    NDIS_STATUS ndisStatus = NDIS_STATUS_SUCCESS;
    DBGPRINT (RT_DEBUG_TRACE, ("Ndis6CommonPortCreateMac\n"));
    do
    {
        pNdisOidRequest->DATA.METHOD_INFORMATION.BytesRead = 0;
        pNdisOidRequest->DATA.METHOD_INFORMATION.BytesWritten = 0;
        pNdisOidRequest->DATA.METHOD_INFORMATION.BytesNeeded = 0;

        if (pNdisOidRequest->DATA.METHOD_INFORMATION.OutputBufferLength < sizeof(DOT11_MAC_INFO))
        {
            DBGPRINT(RT_DEBUG_TRACE, ("The buffer being passed into OID_DOT11_CREATE_MAC is too small(%d)\n", 
                pNdisOidRequest->DATA.METHOD_INFORMATION.OutputBufferLength));
            pNdisOidRequest->DATA.METHOD_INFORMATION.BytesNeeded = sizeof(DOT11_MAC_INFO);
            ndisStatus = NDIS_STATUS_INVALID_LENGTH;
            break;
        }
        //
        // Since OID calls are serialized, we do not expect the NumberOfPorts to change
        // while we are checking the following until this OID is completed. So we do not need 
        // to protect the NumberOfPorts in any way
        //
        if (pAd->NumberOfPorts >= RTMP_MAX_NUMBER_OF_PORT)
        {
            DBGPRINT (RT_DEBUG_TRACE, ("Number of existing ports exceed max supported. Failing new port creation\n"));            
            ndisStatus = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        if(KeGetCurrentIrql() == DISPATCH_LEVEL)
        {
            DBGPRINT(RT_DEBUG_TRACE, ("%s   KeGetCurrentIrql() = DISPATCH_LEVEL\n", __FUNCTION__));
            
            //
            // Defer the processing of this OID to a workitem. It would do the real work
            //
            ndisStatus = Ndis6CommonPortDeferOidRequest(pAd,
                                                        pPort,
                                                        pNdisOidRequest,
                                                        Ndis6CommonPortCreateMacHandler);
            
            if (ndisStatus != NDIS_STATUS_SUCCESS)
            {
                // Failed to defer the oid request, something is wrong
                DBGPRINT(RT_DEBUG_TRACE, ("Failed to defer OID_DOT11_DELETE_MAC request. Status = 0x%08x\n", ndisStatus));
                break;            
            }

            ndisStatus = NDIS_STATUS_PENDING; // Oid would complete asynchronously later
        }
        else
        {
            pPort->DeferredOidRequest = pNdisOidRequest;
            Ndis6CommonPortCreateMacHandler(pPort, NULL);
            ndisStatus = NDIS_STATUS_SUCCESS;
        }
    }while (0);
    return ndisStatus;
}

VOID 
Ndis6CommonPortCreateMacHandler(
    IN PVOID WorkItemContext,
    IN NDIS_HANDLE NdisIoWorkItemHandle
    )
{
    PMP_PORT pPort = (PMP_PORT)WorkItemContext;
    PMP_ADAPTER pAd = pPort->pAd;

#if(COMPILE_WIN8_ABOVE(CURRENT_OS_NDIS_VER))  
    PDOT11_MAC_PARAMETERS pDot11MacPara = NULL;
#endif
    PDOT11_MAC_INFO Dot11MacInfo = NULL;

    PMP_PORT pNewPort = NULL;
    NDIS_PORT_NUMBER portNumber = NDIS_DEFAULT_PORT_NUMBER;
    NDIS_STATUS ndisStatus = NDIS_STATUS_SUCCESS;
    UCHAR MacAddrIndex = 0, Index = 0;
    DBGPRINT (RT_DEBUG_TRACE, ("Ndis6CommonPortCreateMacHandler\n"));
    do
    {
        //First we have to call NdisMAllocatePort to get port number for the new port.
        ndisStatus = N6AllocateNdisPort(pPort, &portNumber);
        if (ndisStatus != NDIS_STATUS_SUCCESS)
        {       
            DBGPRINT (RT_DEBUG_TRACE, ("N6AllocPort fail in RTMPCreateMac\n"));                       
            break;
        }

        // Since
        // 1. Mac address for WFD device will be determined at initailization.
        // 2. System might use port 1 for softap and port 2 for WFD device port, or reversely.
        //
        // So we can not based on port number to get mac address, instead mac address will be fixed for each opmode,
        // 1. MAC_ADDR_INDEX_0 - 1st mac address for station.
        // 2. MAC_ADDR_INDEX_1 - 2nd mac address for softap.
        // 3. MAC_ADDR_INDEX_2 - 3rd mac address for WFD device.
        // 4. MAC_ADDR_INDEX_3 - 4th mac address for WFD role#1.
        // 5. MAC_ADDR_INDEX_4 - 5th mac address for WFD role#2.
        // 6. MAC_ADDR_INDEX_5 - 6th mac address for WFD role#3.
        // 7. MAC_ADDR_INDEX_6 - 7th mac address for virtual station.
        MacAddrIndex = (UCHAR)portNumber;
#if(COMPILE_WIN8_ABOVE(CURRENT_OS_NDIS_VER))  
        if(NDIS_WIN8_ABOVE(pAd))
        {
            if (pPort->DeferredOidRequest->DATA.METHOD_INFORMATION.InputBufferLength > 0)
            {
                pDot11MacPara = (PDOT11_MAC_PARAMETERS)pPort->DeferredOidRequest->DATA.METHOD_INFORMATION.InformationBuffer;
                if ((pDot11MacPara->uOpmodeMask & DOT11_OPERATION_MODE_EXTENSIBLE_AP))
                {
                    MacAddrIndex = MAC_ADDR_INDEX_1;
                }
                else if ((pDot11MacPara->uOpmodeMask & DOT11_OPERATION_MODE_WFD_DEVICE))
                {
                    MacAddrIndex = MAC_ADDR_INDEX_2;
                }
                else if ((pDot11MacPara->uOpmodeMask & DOT11_OPERATION_MODE_WFD_GROUP_OWNER) ||
                        (pDot11MacPara->uOpmodeMask & DOT11_OPERATION_MODE_WFD_CLIENT))
                {
                    for (Index = 0; Index < MAX_NUM_OF_MS_WFD_ROLE; Index++)
                    {
                        if (pAd->MacAddressUsed[Index] == FALSE)
                        {
                            pAd->MacAddressUsed[Index] = TRUE;
                            MacAddrIndex = Index + MAC_ADDR_INDEX_3;
                            break;
                        }
                    }
                }
                else if ((portNumber > 0) && (pDot11MacPara->uOpmodeMask & DOT11_OPERATION_MODE_EXTENSIBLE_STATION))
                {
                    pAd->MacAddressUsed[MAX_NUM_OF_TOTAL_WFD_ROLE - 1] = TRUE;
                    MacAddrIndex = MAX_NUM_OF_TOTAL_WFD_ROLE - 1 + MAC_ADDR_INDEX_3; // index #6
                }
                else
                {
                    MacAddrIndex = (UCHAR)portNumber;
                }
                DBGPRINT (RT_DEBUG_TRACE, ("uOpmodeMask = %x (%x %x %x %x %x), MacAddrIndex = %d \n", pDot11MacPara->uOpmodeMask, 
                    DOT11_OPERATION_MODE_EXTENSIBLE_STATION, DOT11_OPERATION_MODE_EXTENSIBLE_AP,DOT11_OPERATION_MODE_WFD_DEVICE, 
                    DOT11_OPERATION_MODE_WFD_GROUP_OWNER, DOT11_OPERATION_MODE_WFD_CLIENT, MacAddrIndex));

            }
        }
#endif

        //Then we can refer to the correct port data.
        pNewPort = pAd->PortList[portNumber];
        if (pNewPort == NULL)
        {       
            // By default, our ports are EXTSTA_PORTs only. 
            ndisStatus = N6AllocPort(pAd->AdapterHandle, EXTSTA_PORT, PORTSUBTYPE_STA, &pNewPort);
            if (ndisStatus != NDIS_STATUS_SUCCESS)
            {
                DBGPRINT (RT_DEBUG_TRACE, ("N6AllocPort fail in RTMPCreateMac\n"));                       
                break;
            }

            pAd->PortList[portNumber] = pNewPort;

            //Initialize
            pNewPort->pAd = pAd;
            N6InitPort(pNewPort);
        }

        pNewPort->pAd = pAd;
        pNewPort->State = INIT_STATE;
        pNewPort->OwnMACAddressIdx = DEFAULT_BSSID_INDEX;

        
        
#if(COMPILE_WIN8_ABOVE(CURRENT_OS_NDIS_VER))  
        if (NDIS_WIN8_ABOVE(pAd) && pDot11MacPara)
        {
            pNewPort->OpModeMask = pDot11MacPara->uOpmodeMask;
        }
#endif

        // Done creating the new virtual adapter
        Dot11MacInfo = (PDOT11_MAC_INFO)pPort->DeferredOidRequest->DATA.METHOD_INFORMATION.InformationBuffer;

        if(Dot11MacInfo == NULL)
            break;

        Dot11MacInfo->uNdisPortNumber = portNumber;


        //
        // Assign a separate MAC address to this port, using 4 bssid mode
        // 0: 1 bssid
        // 1: 2 bssid
        // 2: 4 bssid
        // 3: 8 bssid
        Ndis6CommonGetNewMacAddress(pAd, MULTI_BSSID_MODE, MacAddrIndex, Dot11MacInfo->MacAddr);

        

        pPort->DeferredOidRequest->DATA.METHOD_INFORMATION.BytesWritten = sizeof(DOT11_MAC_INFO);
        
        COPY_MAC_ADDR(pNewPort->CurrentAddress, Dot11MacInfo->MacAddr);
        pNewPort->PortNumber = portNumber;

        
        //pAd->PortList[pAd->NumberOfPorts] = pNewPort;
        pAd->NumberOfPorts++;
        N6PortUserCfgInit(pNewPort);

        pNewPort->CommonCfg.bAutoTxRateSwitch = TRUE;
        
        PortMlmeInit(pAd, pNewPort);

        UpdatePortDefaultSetting(pNewPort);

        MlmeInfoSetPhyMode(pAd, pNewPort, pNewPort->CommonCfg.PhyMode, TRUE);
        
        MlmeCntPortCntlInit(pNewPort, &pNewPort->Mlme.CntlMachine, NULL);

        MlmeSyncInitMacTab(pNewPort);
        MP_SET_STATE(pNewPort, INIT_STATE);
        pNewPort->bActive = TRUE;

    } while (0);

    //
    // Complete this OID to the OS
    //
    //pendingRequest = Port->PendingOidRequest;
    //Port->PendingOidRequest = NULL;
    N6CompletePendingOID( pAd, PENDING_CREATE_DELETE_MAC, ndisStatus);

#if 1
    if (ndisStatus == NDIS_STATUS_SUCCESS)
    {
        N6PortActivateNdisPort(pAd, portNumber);
    }
#endif

#if 0
    if ((pAd->NumberOfPorts > 1) && (pAd->StaCfg.BssType == BSS_INFRA))
    {
        BssIndex = Ndis6CommonGetBssidIndex(pAd, pPort, MULTI_BSSID_MODE);
    }
    if(OPSTATUS_TEST_FLAG(pAd->PortList[PORT_0],fOP_STATUS_MEDIA_STATE_CONNECTED))
    {
        for(i = 0 ; i < 4; i++)
        {
            if(pPort->SharedKey[BSS0][i].KeyLen != 0)
            {
                AsicAddKeyEntry(pAd,pPort, BSSID_WCID , BssIndex, (UCHAR)i, &pPort->SharedKey[BSS0][i], FALSE, FALSE);
            }
        }
        //re-initial station port group key
        MlmeInfoStaOidSetWEPDefaultKeyID(pAd->PortList[PORT_0]);        
        AsicSetMultiBssid(pAd, pNewPort->CurrentAddress, 0);
    }
#endif
}

NDIS_STATUS 
Ndis6CommonPortDeleteMac(
    IN PMP_ADAPTER pAd,
    IN PMP_PORT pPort,
    IN PNDIS_OID_REQUEST pNdisOidRequest
    )
{
    NDIS_STATUS ndisStatus = NDIS_STATUS_SUCCESS;
    PDOT11_MAC_INFO pMacInfo = NULL;
    BOOLEAN Cancelled =FALSE;
    PMP_PORT pPortToDelete = NULL;
    DBGPRINT (RT_DEBUG_TRACE, ("Ndis6CommonPortDeleteMac\n"));
    do
    {
        pNdisOidRequest->DATA.SET_INFORMATION.BytesRead = 0;
        pNdisOidRequest->DATA.SET_INFORMATION.BytesNeeded = 0;

        if (pNdisOidRequest->RequestType != NdisRequestSetInformation)
        {
            DBGPRINT(RT_DEBUG_ERROR, ("Invalid request type %d for OID_DOT11_DELETE_MAC\n", pNdisOidRequest->RequestType));
            ndisStatus = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        if (pNdisOidRequest->DATA.SET_INFORMATION.InformationBufferLength < sizeof(DOT11_MAC_INFO))
        {
            DBGPRINT(RT_DEBUG_ERROR, ("%s:The buffer being passed into OID_DOT11_DELETE_MAC is too small(%d)", __FUNCTION__, pNdisOidRequest->DATA.SET_INFORMATION.InformationBufferLength));
            pNdisOidRequest->DATA.SET_INFORMATION.BytesNeeded = sizeof(DOT11_MAC_INFO);
            ndisStatus = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        pMacInfo = (PDOT11_MAC_INFO)pNdisOidRequest->DATA.SET_INFORMATION.InformationBuffer;    
        DBGPRINT(RT_DEBUG_TRACE, ("%s: uNdisPortNumber = %d\n", __FUNCTION__, pMacInfo->uNdisPortNumber));
        if ((pMacInfo->uNdisPortNumber >= RTMP_MAX_NUMBER_OF_PORT) ||
            (pMacInfo->uNdisPortNumber == 0) ||
            (pMacInfo->uNdisPortNumber == 0xFFFFFFFF))
        {
            DBGPRINT(RT_DEBUG_ERROR, ("%s:The port number (%d) being passed in is invalid", __FUNCTION__, pMacInfo->uNdisPortNumber));
            ndisStatus = NDIS_STATUS_INVALID_DATA;
            break;
        }

        pPortToDelete = pAd->PortList[pMacInfo->uNdisPortNumber];
        if (pPortToDelete == NULL)
        {
            DBGPRINT(RT_DEBUG_ERROR, ("RTMPDeleteMac, pPort is NULL...\n"));
            ndisStatus = NDIS_STATUS_INVALID_DATA;
            break;
        }
        if (pPortToDelete->bActive == FALSE)
        {
            DBGPRINT(RT_DEBUG_ERROR, ("RTMPDeleteMac, port is not active...\n"));
            ndisStatus = NDIS_STATUS_INVALID_DATA;
            break;
        }
        
        //if this port is in scan, cancel it
        if (pMacInfo->uNdisPortNumber == pAd->ucScanPortNum)
        {
            if (MT_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
            {
                MT_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
                PlatformCancelTimer(&pPort->Mlme.ScanTimer, &Cancelled);   
                pPort->Mlme.SyncMachine.CurrState  = SYNC_IDLE;     
            }

            // when remove device, we shold indicate pending scan request.
            PlatformIndicateScanStatus(pAd, pPort, NDIS_STATUS_REQUEST_ABORTED, TRUE, TRUE);
        }

        if(KeGetCurrentIrql() == DISPATCH_LEVEL)
        {
            DBGPRINT(RT_DEBUG_TRACE, ("%s   KeGetCurrentIrql() = DISPATCH_LEVEL\n", __FUNCTION__));
            
            //
            // Defer the processing of this OID to a workitem. It would do the real work
            //
            ndisStatus = Ndis6CommonPortDeferOidRequest(pAd,
                                                        pPort,
                                                        pNdisOidRequest,
                                                        Ndis6CommonPortDeleteMacHandler);
            
            if (ndisStatus != NDIS_STATUS_SUCCESS)
            {
                // Failed to defer the oid request, something is wrong
                DBGPRINT(RT_DEBUG_TRACE, ("Failed to defer OID_DOT11_DELETE_MAC request. Status = 0x%08x\n", ndisStatus));
                break;            
            }

            ndisStatus = NDIS_STATUS_PENDING; // Oid would complete asynchronously later
        }
        else
        {
            pPort->DeferredOidRequest = pNdisOidRequest;
            Ndis6CommonPortDeleteMacHandler(pPort, NULL);
            ndisStatus = NDIS_STATUS_SUCCESS;
        }
    }while (0);
    return ndisStatus;
}

VOID 
Ndis6CommonPortDeleteMacHandler(
    IN PVOID WorkItemContext,
    IN NDIS_HANDLE NdisIoWorkItemHandle
    )
{
    PMP_PORT pPort = (PMP_PORT)WorkItemContext;
    PMP_ADAPTER pAd = pPort->pAd;
    NDIS_STATUS ndisStatus;
    UCHAR Index = 0;

    //PDOT11_MAC_INFO pMacInfo = (PDOT11_MAC_INFO)pPort->DeferredOidRequest->DATA.SET_INFORMATION.InformationBuffer;
    //ULONG PortNumber = pMacInfo->uNdisPortNumber;
    BOOLEAN Cancelled=FALSE;

    DBGPRINT (RT_DEBUG_TRACE, ("Ndis6CommonPortDeleteMacHandler\n"));

    //
    // Complete this OID to the OS
    //
    //pendingRequest = Port->PendingOidRequest;
    //Port->PendingOidRequest = NULL;
    N6CompletePendingOID( pAd, PENDING_CREATE_DELETE_MAC, NDIS_STATUS_SUCCESS);

    //Refer to port to be deleted
    //pPort = pAd->PortList[PortNumber];

    //to patch ndistes issue, ndistest delete ap port and do not stop AP
    if(pPort->PortType == EXTAP_PORT)
    {
        if (pPort->SoftAP.bAPStart)
    {
        DBGPRINT(RT_DEBUG_TRACE,("[%s][LINE_%d] Delete port, stop SoftAP ... \n",__FUNCTION__,__LINE__));
        APStop(pAd,  pPort);
    }
    }

#if(COMPILE_WIN8_ABOVE(CURRENT_OS_NDIS_VER))  
    if(NDIS_WIN8_ABOVE(pAd))
    {
        //Free WFDSecondaryDeviceTypeList
        P2pMsFreeIeMemory(&pPort->PortCfg.pWFDSecondaryDeviceTypeList,  &pPort->PortCfg.WFDNumOfSecondaryDevice);

        //
        // Reset wfd port number
        //
        if (pPort->PortType == WFD_DEVICE_PORT)
            pPort->P2PCfg.PortNumber = PORT_0;
        if (pPort->PortType == WFD_GO_PORT)
            pPort->P2PCfg.GOPortNumber = PORT_0;
        // clear multiple clients
        if (pPort->PortType == WFD_CLIENT_PORT)
        {
            if (pPort->PortNumber == pPort->P2PCfg.ClientPortNumber)// #1
            {
                pPort->P2PCfg.ClientPortNumber = PORT_0;
                MT_CLEAR_BIT(pPort->P2PCfg.ClientUseBitmap, P2pMs_CLIENT_1_INUSED);
            }
            else if (pPort->PortNumber == pPort->P2PCfg.Client2PortNumber)//#2
            {
                pPort->P2PCfg.Client2PortNumber = PORT_0;
                MT_CLEAR_BIT(pPort->P2PCfg.ClientUseBitmap, P2pMs_CLIENT_2_INUSED);
            }
            pAd->ucActivePortNum = NDIS_DEFAULT_PORT_NUMBER;
        }
        // debug print
        if (pPort->PortType >= WFD_DEVICE_PORT)
        {
        DBGPRINT(RT_DEBUG_TRACE, ("%s: Clear wfd port number (porttype=%d, portnum=%d(%d-%d-%d-%d), cli-bitmap=%d)\n", 
            __FUNCTION__, pPort->PortType, pPort->PortNumber, pPort->P2PCfg.PortNumber, pPort->P2PCfg.GOPortNumber, pPort->P2PCfg.ClientPortNumber, pPort->P2PCfg.Client2PortNumber, pPort->P2PCfg.ClientUseBitmap));
    }
        // Clear MacAddr Inused
        if ((pPort->OpModeMask & DOT11_OPERATION_MODE_WFD_GROUP_OWNER) ||
            (pPort->OpModeMask & DOT11_OPERATION_MODE_WFD_CLIENT))
        {
            for (Index = 0; Index < MAX_NUM_OF_MS_WFD_ROLE; Index++)
            {
                if (MAC_ADDR_EQUAL(pPort->CurrentAddress, pAd->MacAddressList[Index]))
                {
                    pAd->MacAddressUsed[Index] = FALSE;
                    DBGPRINT(RT_DEBUG_TRACE,("[%s][LINE_%d] pAd->MacAddressUsed[%d] = FALSE\n",__FUNCTION__,__LINE__, Index));
                    break;
                }
            }
        }
        else if ((pPort->PortNumber > 0) && (pPort->OpModeMask & DOT11_OPERATION_MODE_EXTENSIBLE_STATION))
        {
            if (MAC_ADDR_EQUAL(pPort->CurrentAddress, pAd->MacAddressList[MAX_NUM_OF_TOTAL_WFD_ROLE - 1]))
            {
                pAd->MacAddressUsed[MAX_NUM_OF_TOTAL_WFD_ROLE - 1] = FALSE;
                
                // Set p2p port number to 0 once virtual port is deleted (exclusive mode)
                pPort->P2PCfg.PortNumber = PORT_0;
                pAd->OpMode = OPMODE_STA;
                pAd->ucActivePortNum = NDIS_DEFAULT_PORT_NUMBER;
                DBGPRINT(RT_DEBUG_TRACE,("[%s][LINE_%d] pAd->MacAddressUsed[%d] = FALSE\n",__FUNCTION__,__LINE__, MAX_NUM_OF_TOTAL_WFD_ROLE - 1));
            }
        }
    }
    else
#endif
    {
        // Set p2p port number to 0 once Port2 is deleted
        if ((pPort->PortNumber == PORT_2) && (pAd->OpMode == OPMODE_STAP2P))
        {
            pPort->P2PCfg.PortNumber = PORT_0;
            pAd->OpMode = OPMODE_STA;
            pAd->ucActivePortNum = NDIS_DEFAULT_PORT_NUMBER;
        }
    }

    MlmePortFreeTimer(pAd, pPort);

    MlmePortFreeWorkItem(pAd, pPort);
    // Clear Additional IE data by each port.
    Ndis6CommonPortFreeVariableIE(pPort);
    // Clear PrivacyExemptionList data by each port.
    Ndis6CommonPortFreePrivacyExemptionList(pPort);
    
    N6PortDeactivateNdisPort(pAd, pPort->PortNumber);
    ndisStatus = NdisMFreePort(pAd->AdapterHandle, pPort->PortNumber);
    if(ndisStatus != NDIS_STATUS_SUCCESS)
    {
        DBGPRINT (RT_DEBUG_TRACE, ("Free ndis port fail\n"));
    }

    DBGPRINT(RT_DEBUG_TRACE,("[%s][LINE_%d] DeactiveNdisPort -->PortNumber =%d, %d\n",__FUNCTION__,__LINE__, pPort->PortNumber, pPort->PortNumber));

    // Init porttype
    pPort->PortType     = EXTSTA_PORT;
    pPort->PortSubtype  = PORTSUBTYPE_STA;

    pPort->bActive = FALSE;

    //Once port created, it will not be freed until driver unload
    //N6FreePort(pPort);

    pAd->NumberOfPorts--;

}

VOID 
Ndis6CommonGetNewMacAddress(
    IN  PMP_ADAPTER   pAd,
    IN  UCHAR           MultiBssidMode,
    IN  UCHAR           PortNumber,
    OUT PUCHAR          pMacAddr
    )
{
    UCHAR Byte = 0;
    UCHAR Mask = 0;

    UCHAR i = 0;
    //ULONG Value;
    UCHAR MacByte = 0, MacMask = 0;

    ASSERT(MultiBssidMode <= MULTI_BSSID_8);
    ASSERT(PortNumber < (1 << MultiBssidMode));

    
    //TODO: Carter, Apcli interface and MESH interface shall use HWBSSID1 or HWBSSID2???
   

    COPY_MAC_ADDR(pMacAddr, pAd->HwCfg.CurrentAddress);

    DBGPRINT(RT_DEBUG_TRACE, ("%s    CurrentAddress = %x %x %x %x %x %x", __FUNCTION__, pMacAddr[0], pMacAddr[1], pMacAddr[2], pMacAddr[3], pMacAddr[4], pMacAddr[5]));
    

#if 0
    //TODO: shall we make choosing which byte to be selectable???
    Value = 0x00000000;
    HW_IO_READ32(pAd, LPON_BTEIR, &Value);//read BTEIR bit[31:29] for determine to choose which byte to extend BSSID mac address.
    Value = Value | (0x2 << 29);//Note: Carter, make default will use byte4 bit[31:28] to extend Mac Address
    HW_IO_WRITE32(pAd, LPON_BTEIR, Value);
    MacByte = Value >> 29;
#endif
#if 0
    Value = 0x00000000;
    //HW_IO_READ32(pAd, RMAC_RMACDR, &Value);
    Value = Value & 0xfcffffff;/* clear bit[25:24] */

    if (MultiBssidMode <= 2) {
    Value &= ~RMACDR_MBSSID_MASK;
    Value |= RMACDR_MBSSID(0x0);
    MacMask = 0xef;
    }
    else if (MultiBssidMode <= 4) {
    Value &= ~RMACDR_MBSSID_MASK;
    Value |= RMACDR_MBSSID(0x1);
    MacMask = 0xcf;
    }
    else if (MultiBssidMode <= 8) {
    Value &= ~RMACDR_MBSSID_MASK;
    Value |= RMACDR_MBSSID(0x2);
    MacMask = 0x8f;
    }
    else if (MultiBssidMode <= 16) {
    Value &= ~RMACDR_MBSSID_MASK;
    Value |= RMACDR_MBSSID(0x3);
    MacMask = 0x0f;
    }
    else {
    Value &= ~RMACDR_MBSSID_MASK;
    Value |= RMACDR_MBSSID(0x3);
    MacMask = 0x0f;
    }

    DBGPRINT(RT_DEBUG_TRACE, ("%s   RMAC_RMACDR = %x \n", __FUNCTION__, Value));


    //HW_IO_WRITE32(pAd, RMAC_RMACDR, Value);
#endif

    MacMask = 0x8f;
    
    if (PortNumber > 0)
    {
        /* MT7603, bit1 in byte0 shall always be b'1 for Multiple BSSID */
        pMacAddr[0] |= 0x2;

        switch (MacByte) {
        case 0x1: /* choose bit[23:20]*/
            pMacAddr[2] = pMacAddr[2] & MacMask;//clear high 4 bits,
            pMacAddr[2] = (pMacAddr[2] | (PortNumber << 4));
        break;
        case 0x2: /* choose bit[31:28]*/
            pMacAddr[3] = pMacAddr[3] & MacMask;//clear high 4 bits,
            pMacAddr[3] = (pMacAddr[3] | (PortNumber << 4));
        break;
        case 0x3: /* choose bit[39:36]*/
            pMacAddr[4] = pMacAddr[4] & MacMask;//clear high 4 bits,
            pMacAddr[4] = (pMacAddr[4] | (PortNumber << 4));
        break;
        case 0x4: /* choose bit [47:44]*/
            pMacAddr[5] = pMacAddr[5] & MacMask;//clear high 4 bits,
            pMacAddr[5] = (pMacAddr[5] | (PortNumber << 4));
        break;
        default: /* choose bit[15:12]*/
            pMacAddr[1] = pMacAddr[1] & MacMask;//clear high 4 bits,
            pMacAddr[1] = (pMacAddr[1] | (PortNumber << 4));
        break;
        }
    }

    DBGPRINT(RT_DEBUG_TRACE, ("%s   nwe Port%d addr = %x %x %x %x %x %x", __FUNCTION__, PortNumber, pMacAddr[0], pMacAddr[1], pMacAddr[2], pMacAddr[3], pMacAddr[4], pMacAddr[5]));
    


#if 0
    COPY_MAC_ADDR(pMacAddr, pAd->HwCfg.CurrentAddress);
   
    
    if (PortNumber > 0)
    {
        //set bit[1] (local admin bit)
        pMacAddr[0] = pMacAddr[0] | 0x02;

        //bit[n:2] is index
        Byte = PortNumber;
        Byte--;
        Byte = (Byte << 2);
        pMacAddr[0] = pMacAddr[0] | Byte;
    }
#endif
}

UCHAR 
Ndis6CommonGetBssidIndex(
    IN  PMP_ADAPTER   pAd,
    IN  PMP_PORT      pPort,
    IN  UCHAR           MultiBssidMode
    )
{
    UCHAR Index = 0;
    UCHAR Mask = 0;

    UCHAR i = 0;

    ASSERT(MultiBssidMode <= MULTI_BSSID_8);

    
    {
        //bit [n:2] is the mask
        for (i = 0; i < MultiBssidMode; i++)
        {
            Mask = Mask | (1 << i);
        }
        Mask = (Mask << 2);

        //It will be index other than 0 only when bit 1 is set
        if (pPort->CurrentAddress[0] & 0x02)
        {
            Index = pPort->CurrentAddress[0] & Mask;
            Index = (Index >> 2);
            Index++;
        }
    }
    
    return Index;
}

NDIS_STATUS 
Ndis6CommonPortSetNicPowerState(
    IN PMP_ADAPTER pAd,
    IN PMP_PORT pPort,
    IN PNDIS_OID_REQUEST pNdisOidRequest
    )
{
    //NDIS_STATUS ndisStatus = NDIS_STATUS_SUCCESS;
    /* 
    For NDIS Test Assertion: 76065 Waiting on the NDIS_STATUS_DOT11_PHY_STATE_CHANGED failed.
    Expected to receive this indication when the PHY on which GO is hosted is turned OFF. 
    */
    NDIS_STATUS ndisStatus = NDIS_STATUS_DOT11_PHY_STATE_CHANGED ;
    ULONG bPowerOn;

    do
    {
        pNdisOidRequest->DATA.SET_INFORMATION.BytesRead = 0;
        pNdisOidRequest->DATA.SET_INFORMATION.BytesNeeded = 0;
        if (pNdisOidRequest->DATA.SET_INFORMATION.InformationBufferLength < sizeof(BOOLEAN))
        {
            pNdisOidRequest->DATA.SET_INFORMATION.BytesNeeded = sizeof(BOOLEAN);
            ndisStatus = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        bPowerOn = *(PULONG)pNdisOidRequest->DATA.SET_INFORMATION.InformationBuffer;
        pNdisOidRequest->DATA.SET_INFORMATION.BytesRead = sizeof(BOOLEAN);

        if (bPowerOn == (ULONG)(pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio))
        {
            //
            // No need to take status indications if it is
            // already in the correct state
            //
            return NDIS_STATUS_SUCCESS;
        }
        //
        // Set the Radio state
        //
        if (bPowerOn)
        {
            pAd->StaCfg.bSwRadio = TRUE;  //SwRadio On
        }
        else
        {
            pAd->StaCfg.bSwRadio = FALSE;
        }

        if(KeGetCurrentIrql() == DISPATCH_LEVEL)
        {
            DBGPRINT(RT_DEBUG_TRACE, ("%s   KeGetCurrentIrql() = DISPATCH_LEVEL\n", __FUNCTION__));
            
            //
            // Defer the processing of this OID to a workitem. It would do the real work
            //
            ndisStatus = Ndis6CommonPortDeferOidRequest(pAd,
                                                        pPort,
                                                        pNdisOidRequest,
                                                        Ndis6CommonPortSetNicPowerStateHandler);
            
            if (ndisStatus != NDIS_STATUS_SUCCESS)
            {
                // Failed to defer the oid request, something is wrong
                DBGPRINT(RT_DEBUG_TRACE, ("Failed to defer OID_DOT11_DELETE_MAC request. Status = 0x%08x\n", ndisStatus));
                break;            
            }

            ndisStatus = NDIS_STATUS_PENDING; // Oid would complete asynchronously later
        }
        else
        {
            pPort->DeferredOidRequest = pNdisOidRequest;
            Ndis6CommonPortSetNicPowerStateHandler(pPort, NULL);
            ndisStatus = NDIS_STATUS_SUCCESS;
        }
    }while (0);
    return ndisStatus;
}

VOID 
Ndis6CommonPortSetNicPowerStateHandler(
    IN PVOID WorkItemContext,
    IN NDIS_HANDLE NdisIoWorkItemHandle
    )
{
    PMP_PORT pPort = (PMP_PORT)WorkItemContext;
    PMP_ADAPTER pAd = pPort->pAd;

    if (pAd->StaCfg.bRadio != (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio))
    {
        pAd->StaCfg.bRadio = (pAd->StaCfg.bHwRadio && pAd->StaCfg.bSwRadio);

        if (pAd->StaCfg.bRadio == TRUE)
        {
            DBGPRINT_RAW(RT_DEBUG_TRACE, ("!!! Radio On !!!\n"));

            MlmeRadioOn(pAd);
            // Update extra information
            pAd->UiCfg.ExtraInfo = EXTRA_INFO_CLEAR;
        }
        else
        {
            DBGPRINT_RAW(RT_DEBUG_ERROR, ("!!! Radio Off !!!\n"));

            if (MT_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
            {
                NDIS_STATUS  ndisStatus = NDIS_STATUS_SUCCESS;
                
                XmitResumeMsduTransmission(pAd);
                
                ndisStatus = NDIS_STATUS_SUCCESS;
                pAd->MlmeAux.bNeedPlatformIndicateScanStatus = FALSE;
                
                PlatformIndicateScanStatus(pAd, pPort, ndisStatus, TRUE, FALSE);
                
                DBGPRINT(RT_DEBUG_TRACE, ("MLME: %s, Indicate scan confirm\n",__FUNCTION__));
            }

            // From WDK spec.
            PlatformIndicateScanStatus(pAd, pAd->PortList[pAd->ucScanPortNum], NDIS_STATUS_UNSUPPORTED_MEDIA, TRUE, TRUE);
            
            MlmeRadioOff(pAd, pPort);
            // Update extra information
            pAd->UiCfg.ExtraInfo = HW_RADIO_OFF;

            //pAd->StaCfg.bDelayedPhyPowerIndication = FALSE;
        }
    }

    RTMPSetRegistrySwRadioOff(pAd, !pAd->StaCfg.bSwRadio);

    PlatformIndicateCurrentPhyPowerState(pAd, pPort->PortNumber,DOT11_PHY_ID_ANY);

    //
    // Complete this OID to the OS
    //
    //pendingRequest = Port->PendingOidRequest;
    //Port->PendingOidRequest = NULL;
    N6CompletePendingOID( pAd, PENDING_NIC_POWER_STATE, NDIS_STATUS_SUCCESS);

}

PMP_PORT
Ndis6CommonGetStaPort(
    IN PMP_ADAPTER pAd
    )
{
    UCHAR PortNum;
    for (PortNum = 0; PortNum < RTMP_MAX_NUMBER_OF_PORT/*pAd->NumberOfPorts*/; PortNum++)
    {
        if ((pAd->PortList[PortNum] == NULL) || (pAd->PortList[PortNum]->bActive == FALSE))
        {
            continue;
        }

        if( pAd->PortList[PortNum]->PortType == EXTSTA_PORT)
            return  pAd->PortList[PortNum];
    }
    return NULL;
}

VOID
Ndis6CommonCheckanyPortConnected(
    IN  PMP_ADAPTER pAd,
    OUT NDIS_PORT_NUMBER  *PortNumber, 
    OUT BOOLEAN *bConnected
    )
{
    UCHAR PortNum;
    *bConnected =FALSE;
    for (PortNum = 0; PortNum < RTMP_MAX_NUMBER_OF_PORT/*pAd->NumberOfPorts*/; PortNum++)
    {
        if ((pAd->PortList[PortNum] == NULL) || (pAd->PortList[PortNum]->bActive == FALSE))
        {
            continue;
        }

        if( pAd->PortList[PortNum]->PortType == EXTSTA_PORT)
        {
            if( OPSTATUS_TEST_FLAG(pAd->PortList[PortNum],fOP_STATUS_MEDIA_STATE_CONNECTED))
            {
                *bConnected  = TRUE;
                *PortNumber = pAd->PortList[PortNum]->PortNumber;
                DBGPRINT(RT_DEBUG_TRACE, ("Ndis6CommonCheckanyPortConnected :num=%d,opflag =%x\n",PortNum,pAd->PortList[PortNum]->PortCfg.OpStatusFlags));
            }
        }
    }
}

NDIS_STATUS
Ndis6CommonSetDesiredPhyIdList(
    IN PMP_ADAPTER pAd,
    IN PMP_PORT     pPort,
    IN PULONG       PhyIDList,
    IN ULONG        PhyIDCount)
{
    ULONG                       phyId;

    if (PhyIDCount < 1)
        return NDIS_STATUS_INVALID_DATA;

    if (PhyIDList[0] == DOT11_PHY_ID_ANY)
        return NDIS_STATUS_SUCCESS;

    phyId = PhyIDList[0];
    if (phyId < pAd->StaCfg.pSupportedPhyTypes->uNumOfEntries)
    {
        pPort->CommonCfg.DefaultPhyId = phyId;
    }
    DBGPRINT(RT_DEBUG_TRACE, ("Ndis6CommonSetDesiredPhyIdList, phyId=%d\n", phyId));

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
Ndis6CommonQueryStatistics(
    IN PMP_ADAPTER pAd,
    IN NDIS_OID         Oid,
    IN OUT PVOID        StatBuffer,
    IN OUT PULONG       BytesWritten
    )
{
    ULONG                   PhyId = 0;
    ULONGLONG               StatValue = 0;
    NDIS_STATISTICS_INFO    StatStruct;

    PlatformZeroMemory(&StatStruct, sizeof(NDIS_STATISTICS_INFO));
    StatStruct.Header.Revision = NDIS_OBJECT_REVISION_1;
    StatStruct.Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
    StatStruct.Header.Size = NDIS_SIZEOF_STATISTICS_INFO_REVISION_1;

    StatStruct.SupportedStatistics = NDIS_STATISTICS_FLAGS_VALID_RCV_DISCARDS          |
                                     NDIS_STATISTICS_FLAGS_VALID_RCV_ERROR             |
                                     NDIS_STATISTICS_FLAGS_VALID_XMIT_ERROR            |
                                     NDIS_STATISTICS_FLAGS_VALID_DIRECTED_FRAMES_RCV   |
                                     NDIS_STATISTICS_FLAGS_VALID_DIRECTED_FRAMES_XMIT;

    //
    // Merge phy counters
    //
    for (PhyId = 0; PhyId < 1; PhyId++)
    {
        switch (Oid)
        {
            case OID_GEN_XMIT_OK:
                StatValue += pAd->Counter.StatisticsInfo.PhyCounters[PhyId].ullTransmittedFragmentCount;
                break;

            case OID_GEN_XMIT_ERROR:
                StatValue += pAd->Counter.StatisticsInfo.PhyCounters[PhyId].ullFailedCount;
                break;

            case OID_GEN_RCV_OK:
                StatValue += pAd->Counter.StatisticsInfo.PhyCounters[PhyId].ullReceivedFragmentCount;
                break;

            case OID_GEN_RCV_ERROR:
                StatValue += pAd->Counter.StatisticsInfo.PhyCounters[PhyId].ullFCSErrorCount;
                break;

            case OID_GEN_RCV_CRC_ERROR:
                StatValue += pAd->Counter.StatisticsInfo.PhyCounters[PhyId].ullFCSErrorCount;
                break;

            case OID_GEN_STATISTICS:
                StatStruct.ifInDiscards += pAd->Counter.StatisticsInfo.PhyCounters[PhyId].ullFCSErrorCount;
                StatStruct.ifInErrors += pAd->Counter.StatisticsInfo.PhyCounters[PhyId].ullFCSErrorCount;
                           
                StatStruct.ifHCInUcastPkts += pAd->Counter.StatisticsInfo.PhyCounters[PhyId].ullReceivedFragmentCount;                           
                StatStruct.ifHCOutUcastPkts += pAd->Counter.StatisticsInfo.PhyCounters[PhyId].ullTransmittedFragmentCount;
                
                StatStruct.ifOutErrors += pAd->Counter.StatisticsInfo.PhyCounters[PhyId].ullFailedCount;
                break;
        }
    }
    

    //
    // For some OIDs, we add other stats
    //

    switch (Oid)
    {
        case OID_GEN_XMIT_ERROR:
            #ifdef USE_NWIFI_SPEC_1_66
                StatValue += pAd->Counter.StatisticsInfo.TxError;
            #else
                StatValue += pAd->Counter.StatisticsInfo.UcastCounters.ullTransmittedFailureFrameCount;
                StatValue += pAd->Counter.StatisticsInfo.McastCounters.ullTransmittedFailureFrameCount;
            #endif
            break;

        case OID_GEN_RCV_ERROR:
            #ifdef USE_NWIFI_SPEC_1_66
                StatValue += pAd->Counter.StatisticsInfo.RxError;
            #else
                StatValue += pAd->Counter.StatisticsInfo.UcastCounters.ullReceivedFailureFrameCount;
                StatValue += pAd->Counter.StatisticsInfo.McastCounters.ullReceivedFailureFrameCount;
            #endif
            break;

        case OID_GEN_RCV_NO_BUFFER:
            StatValue = pAd->Counter.StatisticsInfo.RxNoBuf;
            break;

        case OID_GEN_STATISTICS:
            StatStruct.ifInDiscards += (pAd->Counter.StatisticsInfo.RxNoBuf +
                                        pAd->Counter.StatisticsInfo.UcastCounters.ullReceivedFailureFrameCount +
                                        pAd->Counter.StatisticsInfo.McastCounters.ullReceivedFailureFrameCount
                                        );

            StatStruct.ifInErrors += (pAd->Counter.StatisticsInfo.UcastCounters.ullReceivedFailureFrameCount +
                                        pAd->Counter.StatisticsInfo.McastCounters.ullReceivedFailureFrameCount
                                        );

            StatStruct.ifOutErrors += (pAd->Counter.StatisticsInfo.UcastCounters.ullTransmittedFailureFrameCount +
                                        pAd->Counter.StatisticsInfo.McastCounters.ullTransmittedFailureFrameCount
                                        );

            break;
    }

    if (Oid == OID_GEN_STATISTICS)
    {
        PlatformMoveMemory(StatBuffer, &StatStruct, sizeof(NDIS_STATISTICS_INFO));    
        *BytesWritten = sizeof(NDIS_STATISTICS_INFO);
    }
    else
    {
        PlatformMoveMemory(StatBuffer, &StatValue, sizeof(ULONGLONG));
        *BytesWritten = sizeof(ULONGLONG);
    }

    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
Ndis6CommonQuerySupportedPHYTypes(
    IN PMP_ADAPTER pAd,
    IN  ULONG uNumMaxEntries,
    OUT PDOT11_SUPPORTED_PHY_TYPES pDot11SupportedPhyTypes
    )
{
    USHORT    Index;
    if (uNumMaxEntries < pAd->StaCfg.pSupportedPhyTypes->uNumOfEntries) 
    {
        pDot11SupportedPhyTypes->uTotalNumOfEntries = pAd->StaCfg.pSupportedPhyTypes->uNumOfEntries;    
        pDot11SupportedPhyTypes->uNumOfEntries = uNumMaxEntries;

        for (Index = 0; Index < uNumMaxEntries; Index++)
            pDot11SupportedPhyTypes->dot11PHYType[Index] = pAd->StaCfg.pSupportedPhyTypes->dot11PHYType[Index];     

        return NDIS_STATUS_BUFFER_OVERFLOW;     
    }
    else
    {
        pDot11SupportedPhyTypes->uTotalNumOfEntries = pAd->StaCfg.pSupportedPhyTypes->uNumOfEntries;
        pDot11SupportedPhyTypes->uNumOfEntries = pAd->StaCfg.pSupportedPhyTypes->uNumOfEntries;

        for (Index = 0; Index < pAd->StaCfg.pSupportedPhyTypes->uNumOfEntries; Index++)
        {   
            pDot11SupportedPhyTypes->dot11PHYType[Index] = pAd->StaCfg.pSupportedPhyTypes->dot11PHYType[Index];
        }       
        DBGPRINT(RT_DEBUG_INFO, (">>> Ndis6CommonQuerySupportedPHYTypes uNumMaxEntries=  %d <<<\n",uNumMaxEntries)); 
        return NDIS_STATUS_SUCCESS;
    }
}

NDIS_STATUS
Ndis6CommonQueryCurrentSupportedPHYTypes(
    IN PMP_ADAPTER pAd,
    IN PMP_PORT     pPort,
    IN  ULONG uNumMaxEntries,
    OUT PDOT11_SUPPORTED_PHY_TYPES pDot11SupportedPhyTypes
    )
{
    switch (pPort->CommonCfg.PhyMode)
        {
                case PHY_11BG_MIXED:        // 0
                {
                    pDot11SupportedPhyTypes->uTotalNumOfEntries = 2;    
                    pDot11SupportedPhyTypes->uNumOfEntries = 2;
                    pDot11SupportedPhyTypes->dot11PHYType[0] = dot11_phy_type_hrdsss;
                    pDot11SupportedPhyTypes->dot11PHYType[1] = dot11_phy_type_erp;
                    break;
                }
    
                case PHY_11B:       // 1
                {
                    pDot11SupportedPhyTypes->uTotalNumOfEntries = 1;    
                    pDot11SupportedPhyTypes->uNumOfEntries = 1;
                    pDot11SupportedPhyTypes->dot11PHYType[0] = dot11_phy_type_hrdsss;
                    break;
                }
                case PHY_11A:       // 2
                {
                    pDot11SupportedPhyTypes->uTotalNumOfEntries = 1;    
                    pDot11SupportedPhyTypes->uNumOfEntries = 1;
                    pDot11SupportedPhyTypes->dot11PHYType[0] = dot11_phy_type_ofdm;
                    break;
                }
                case PHY_11ABG_MIXED:       // 3
                {
                    pDot11SupportedPhyTypes->uTotalNumOfEntries = 3;    
                    pDot11SupportedPhyTypes->uNumOfEntries = 3;
                    pDot11SupportedPhyTypes->dot11PHYType[0] = dot11_phy_type_hrdsss;
                    pDot11SupportedPhyTypes->dot11PHYType[1] = dot11_phy_type_ofdm;
                    pDot11SupportedPhyTypes->dot11PHYType[2] = dot11_phy_type_erp;
                    break;
                }
                
                case PHY_11G:       // 4
                {
                    pDot11SupportedPhyTypes->uTotalNumOfEntries = 1;    
                    pDot11SupportedPhyTypes->uNumOfEntries = 1;
                    pDot11SupportedPhyTypes->dot11PHYType[0] = dot11_phy_type_erp;
                    break;
                }
                case PHY_11ABGN_MIXED:  // both band   5
                case PHY_11VHT:
                {
                    pDot11SupportedPhyTypes->uTotalNumOfEntries = 4;    
                    pDot11SupportedPhyTypes->uNumOfEntries = 4;
                    pDot11SupportedPhyTypes->dot11PHYType[0] = dot11_phy_type_hrdsss;
                    pDot11SupportedPhyTypes->dot11PHYType[1] = dot11_phy_type_ofdm;
                    pDot11SupportedPhyTypes->dot11PHYType[2] = dot11_phy_type_erp;
                    pDot11SupportedPhyTypes->dot11PHYType[3] = dot11_phy_type_ht;
                    break;
                }
                case PHY_11N:       //6
                {
                    pDot11SupportedPhyTypes->uTotalNumOfEntries = 1;    
                    pDot11SupportedPhyTypes->uNumOfEntries = 1;
                    pDot11SupportedPhyTypes->dot11PHYType[0] = dot11_phy_type_ht;
                    break;
                }
                case PHY_11GN_MIXED:        // 7
                {
                    pDot11SupportedPhyTypes->uTotalNumOfEntries = 2;    
                    pDot11SupportedPhyTypes->uNumOfEntries = 2;
                    pDot11SupportedPhyTypes->dot11PHYType[0] = dot11_phy_type_erp;
                    pDot11SupportedPhyTypes->dot11PHYType[1] = dot11_phy_type_ht;
                    break;
                }
                case PHY_11AN_MIXED:        // 8
                {
                    pDot11SupportedPhyTypes->uTotalNumOfEntries = 2;    
                    pDot11SupportedPhyTypes->uNumOfEntries = 2;
                    pDot11SupportedPhyTypes->dot11PHYType[0] = dot11_phy_type_ofdm;
                    pDot11SupportedPhyTypes->dot11PHYType[1] = dot11_phy_type_ht;
                    break;
                }
                case PHY_11BGN_MIXED:   //  9
                {
                    pDot11SupportedPhyTypes->uTotalNumOfEntries = 3;    
                    pDot11SupportedPhyTypes->uNumOfEntries = 3;
                    pDot11SupportedPhyTypes->dot11PHYType[0] = dot11_phy_type_hrdsss;
                    pDot11SupportedPhyTypes->dot11PHYType[1] = dot11_phy_type_erp;
                    pDot11SupportedPhyTypes->dot11PHYType[2] = dot11_phy_type_ht;
                    break;
                }
                case PHY_11AGN_MIXED: //10
                {
                    pDot11SupportedPhyTypes->uTotalNumOfEntries = 3;    
                    pDot11SupportedPhyTypes->uNumOfEntries = 3;
                    pDot11SupportedPhyTypes->dot11PHYType[0] = dot11_phy_type_ofdm;
                    pDot11SupportedPhyTypes->dot11PHYType[1] = dot11_phy_type_erp;
                    pDot11SupportedPhyTypes->dot11PHYType[2] = dot11_phy_type_ht;
                    break;
                }
                default:
                    break;
        }
        return NDIS_STATUS_SUCCESS;
}

VOID
Ndis6CommonReportEthFrameToLLC(
    IN  PMP_ADAPTER   pAd,
    IN  PMP_PORT      pPort,
    IN  PUCHAR          p80211DataFrame,
    IN  USHORT          us80211FrameSize,
    IN  UCHAR           UserPriority,
    IN  BOOLEAN         CRCError,
    IN  BOOLEAN         bSingleIndicate
    )
{
    PNET_BUFFER                 NetBuffer;
    PMP_LOCAL_RX_PKTS  pIndicateRxPkts = NULL;
    PHEADER_802_11              pHeader80211 = NULL;    
    PQUEUE_HEADER               pQueue;
    NDIS_NET_BUFFER_LIST_8021Q_INFO Ndis8021QInfo;

    NdisAcquireSpinLock(&pAd->pRxCfg->IndicateRxPktsQueueLock);
    pQueue = (PQUEUE_HEADER) &pAd->pRxCfg->IndicateRxPktsQueue;
    if (pQueue->Head != NULL)
        pIndicateRxPkts = (PMP_LOCAL_RX_PKTS)RemoveHeadQueue(pQueue);
    NdisReleaseSpinLock(&pAd->pRxCfg->IndicateRxPktsQueueLock);

    if (pIndicateRxPkts == NULL)
    {
        DBGPRINT(RT_DEBUG_ERROR, ("Ndis6CommonReportEthFrameToLLC failed!\n"));
        return;
    }

    //
    // Add FCS FAILURE Info. in Receive Flag if in Network monitor mode and CRC is Error
    //
    if (CRCError && pPort->PortCfg.OperationMode == DOT11_OPERATION_MODE_NETWORK_MONITOR)
    {
        pIndicateRxPkts->Dot11RecvContext.uReceiveFlags = DOT11_RECV_FLAG_RAW_PACKET_FCS_FAILURE;
    }   

    Ndis6CommonFillReceiveContext(pAd, pPort, &pIndicateRxPkts->Dot11RecvContext,0);
    
    NetBuffer = NET_BUFFER_LIST_FIRST_NB(pIndicateRxPkts->NetBufferList);

    NET_BUFFER_DATA_LENGTH(NetBuffer) = us80211FrameSize;

    if (0)
    {
        int i = 0;
        PUCHAR p = (PUCHAR)p80211DataFrame;
        DBGPRINT(RT_DEBUG_TRACE, ("Ndis6CommonReportEthFrameToLLC->\n"));
        //for (i = 0; i < (int)pRxD->RxDscrDW0.RxByteCount; i = i + 8)
        for (i = 0; i < us80211FrameSize; i = i + 8)
        {
            DBGPRINT_RAW(RT_DEBUG_ERROR, ("[%d] %x %x %x %x %x %x %x %x\n", i, p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5], p[i+6], p[i+7]));
        }
    }   
    
    MmInitializeMdl(pIndicateRxPkts->Mdl, p80211DataFrame, us80211FrameSize);

    pIndicateRxPkts->Mdl->MdlFlags = MDL_SOURCE_IS_NONPAGED_POOL ;

    MmBuildMdlForNonPagedPool(pIndicateRxPkts->Mdl);
    
    MT_SET_NETBUFFERLIST_IN_NBL(pIndicateRxPkts->NetBufferList, pIndicateRxPkts);
    MT_SET_RECEIVE_CONTEXT(pIndicateRxPkts->NetBufferList, &pIndicateRxPkts->Dot11RecvContext); 

    //user priority
    Ndis8021QInfo.Value = 0;
    Ndis8021QInfo.WLanTagHeader.WMMInfo = UserPriority;
    NET_BUFFER_LIST_INFO(pIndicateRxPkts->NetBufferList, Ieee8021QNetBufferListInfo) = Ndis8021QInfo.Value; 

    NET_BUFFER_LIST_NEXT_NBL(pIndicateRxPkts->NetBufferList) = NULL;

    //
    // We can only indicate receive packet when the adpater state is in Nic running state
    // Otherwise, it will cause problem when we indicate at wrong time.
    //
    if (pAd->AdapterState == NicRunning)
    {
        // Specifies that the STA reclaims ownership of the NET_BUFFER_LIST structures and any attached
        // NET_BUFFER structures immediately after the call to NdisMIndicateReceiveNetBufferLists returns.
#if 0
        NdisMIndicateReceiveNetBufferLists(pAd->AdapterHandle,
                                            pIndicateRxPkts->NetBufferList,
                                            pPort->PortNumber,
                                            1,
                                            NDIS_RECEIVE_FLAGS_RESOURCES);
#endif
        if (pAd->pHifCfg->bBulkInRead == TRUE || bSingleIndicate == TRUE)
        {
            PlatformIndicatePktToNdis(pAd, (PVOID)pIndicateRxPkts->NetBufferList, pPort->PortNumber, 1);
        }
        else
        {
            NdisAcquireSpinLock(&pAd->pRxCfg->IndicateRxPktsLock[pPort->PortNumber]);
            if (pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] == NULL)
            {
                pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] = 1;
            }
            else
            {
                NET_BUFFER_LIST_NEXT_NBL((PNET_BUFFER_LIST)pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber]) = pIndicateRxPkts->NetBufferList;
                pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = pIndicateRxPkts->NetBufferList;
                pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] ++;
            }
#if 0
            if ((pPort->CommonCfg.BACapability.field.AutoBA == FALSE) || (pPort->CommonCfg.PhyMode < PHY_11ABGN_MIXED))
            {
                Ndis6PlatformIndicatePktToNdis(pAd, (PVOID)pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber], pPort->PortNumber, pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber]);
                pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = NULL;
                pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] = NULL;
                pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] = 0;
            }
#endif          
            NdisReleaseSpinLock(&pAd->pRxCfg->IndicateRxPktsLock[pPort->PortNumber]);
        }
    }
    
#if 0   // If NOT use the flag as NDIS_RECEIVE_FLAGS_RESOURCES to Ndis, finish InsertTailQueue(IndicateRxPktsQueue) in N6ReturnNetBufferLists
    NdisAcquireSpinLock(&pAd->pRxCfg->IndicateRxPktsQueueLock);
    InsertTailQueue(&pAd->pRxCfg->IndicateRxPktsQueue, pIndicateRxPkts);
    NdisReleaseSpinLock(&pAd->pRxCfg->IndicateRxPktsQueueLock);
#endif  
    INC_COUNTER64(pAd->Counter.Counters8023.GoodReceives);
}

VOID
Ndis6CommonReportEthFrameToLLCAgg(
    IN  PMP_ADAPTER  pAd,
    IN  PMP_PORT  pPort,
    IN  PUCHAR  p80211Header,
    IN  USHORT  Payload1Size,
    IN  USHORT  Payload2Size,
    IN  UCHAR   UserPriority)
{
    PNET_BUFFER     NetBuffer;
    PMP_LOCAL_RX_PKTS pIndicateRxPkts = NULL;
    PQUEUE_HEADER   pQueue;
    NDIS_NET_BUFFER_LIST_8021Q_INFO Ndis8021QInfo;

    NdisAcquireSpinLock(&pAd->pRxCfg->IndicateRxPktsQueueLock);
    pQueue = (PQUEUE_HEADER) &pAd->pRxCfg->IndicateRxPktsQueue;
    if (pQueue->Head != NULL)
        pIndicateRxPkts = (PMP_LOCAL_RX_PKTS)RemoveHeadQueue(pQueue);
    NdisReleaseSpinLock(&pAd->pRxCfg->IndicateRxPktsQueueLock);

    if (pIndicateRxPkts == NULL)
    {
        DBGPRINT(RT_DEBUG_ERROR, ("Ndis6CommonReportEthFrameToLLC failed!\n"));
        return;
    }

    Ndis6CommonFillReceiveContext(pAd, pPort, &pIndicateRxPkts->Dot11RecvContext,0);

    NetBuffer = NET_BUFFER_LIST_FIRST_NB(pIndicateRxPkts->NetBufferList);

    NET_BUFFER_DATA_LENGTH(NetBuffer) = Payload1Size + LENGTH_802_11;

    MmInitializeMdl(pIndicateRxPkts->Mdl, p80211Header, Payload1Size + LENGTH_802_11);
    MmBuildMdlForNonPagedPool(pIndicateRxPkts->Mdl);

    NdisAdjustMdlLength(pIndicateRxPkts->Mdl, Payload1Size + LENGTH_802_11); 
    
    MT_SET_NETBUFFERLIST_IN_NBL(pIndicateRxPkts->NetBufferList, pIndicateRxPkts);
    MT_SET_RECEIVE_CONTEXT(pIndicateRxPkts->NetBufferList, &pIndicateRxPkts->Dot11RecvContext);

    NET_BUFFER_LIST_NEXT_NBL(pIndicateRxPkts->NetBufferList) = NULL;
    
    //user priority
    Ndis8021QInfo.Value = 0;
    Ndis8021QInfo.WLanTagHeader.WMMInfo = UserPriority;
    NET_BUFFER_LIST_INFO(pIndicateRxPkts->NetBufferList, Ieee8021QNetBufferListInfo) = Ndis8021QInfo.Value; 

    //
    // We can only indicate receive packet when the adpater state is in Nic running state
    // Otherwise, it will cause problem when we indicate at wrong time.
    //
    if (pAd->AdapterState == NicRunning)
    {
#if 0
        NdisMIndicateReceiveNetBufferLists(pAd->AdapterHandle,
                                            pIndicateRxPkts->NetBufferList,
                                            pPort->PortNumber,
                                            1,
                                            NDIS_RECEIVE_FLAGS_RESOURCES);
#endif
        if (pAd->pHifCfg->bBulkInRead == TRUE)
        {
            PlatformIndicatePktToNdis(pAd, (PVOID)pIndicateRxPkts->NetBufferList, pPort->PortNumber, 1);
        }
        else
        {
            NdisAcquireSpinLock(&pAd->pRxCfg->IndicateRxPktsLock[pPort->PortNumber]);
            if (pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] == NULL)
            {
                pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] = 1;
            }
            else
            {
                NET_BUFFER_LIST_NEXT_NBL((PNET_BUFFER_LIST)pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber]) = pIndicateRxPkts->NetBufferList;
                pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] ++;
            }

#if 0
            if ((pPort->CommonCfg.BACapability.field.AutoBA == FALSE) || (pPort->CommonCfg.PhyMode < PHY_11ABGN_MIXED))
            {
                Ndis6PlatformIndicatePktToNdis(pAd, (PVOID)pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber], pPort->PortNumber, pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber]);
                pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = NULL;
                pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] = NULL;
                pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] = 0;
            }
#endif          
            NdisReleaseSpinLock(&pAd->pRxCfg->IndicateRxPktsLock[pPort->PortNumber]);
        }
    }
    //
    // Indicate 2's Msdu
    //
    PlatformMoveMemory(p80211Header + LENGTH_802_11 + Payload1Size + 6, SNAP_802_1H, 6);
    PlatformMoveMemory(p80211Header + Payload1Size + 6, p80211Header, LENGTH_802_11);

    NetBuffer = NET_BUFFER_LIST_FIRST_NB(pIndicateRxPkts->NetBufferList);

    NET_BUFFER_DATA_LENGTH(NetBuffer) = Payload2Size + LENGTH_802_11 + LENGTH_802_1_H;

    MmInitializeMdl(pIndicateRxPkts->Mdl, p80211Header + Payload1Size + 6, Payload2Size + LENGTH_802_11 + LENGTH_802_1_H);
    MmBuildMdlForNonPagedPool(pIndicateRxPkts->Mdl);

    NdisAdjustMdlLength(pIndicateRxPkts->Mdl, Payload2Size + LENGTH_802_11 + LENGTH_802_1_H);    
    
    MT_SET_NETBUFFERLIST_IN_NBL(pIndicateRxPkts->NetBufferList, pIndicateRxPkts);
    MT_SET_RECEIVE_CONTEXT(pIndicateRxPkts->NetBufferList, &pIndicateRxPkts->Dot11RecvContext);

    NET_BUFFER_LIST_NEXT_NBL(pIndicateRxPkts->NetBufferList) = NULL;
    
    //user priority
    Ndis8021QInfo.Value = 0;
    Ndis8021QInfo.WLanTagHeader.WMMInfo = UserPriority;
    NET_BUFFER_LIST_INFO(pIndicateRxPkts->NetBufferList, Ieee8021QNetBufferListInfo) = Ndis8021QInfo.Value; 

    //
    // We can only indicate receive packet when the adpater state is in Nic running state
    // Otherwise, it will cause problem when we indicate at wrong time.
    //
    if (pAd->AdapterState == NicRunning)
    {
#if 0
        NdisMIndicateReceiveNetBufferLists(pAd->AdapterHandle,
                                            pIndicateRxPkts->NetBufferList,
                                            pPort->PortNumber,
                                            1,
                                            NDIS_RECEIVE_FLAGS_RESOURCES);
#endif
        if (pAd->pHifCfg->bBulkInRead == TRUE)
        {
            PlatformIndicatePktToNdis(pAd, (PVOID)pIndicateRxPkts->NetBufferList, pPort->PortNumber, 1);
        }
        else
        {
            NdisAcquireSpinLock(&pAd->pRxCfg->IndicateRxPktsLock[pPort->PortNumber]);
            if (pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] == NULL)
            {
                pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] = 1;
            }
            else
            {
                NET_BUFFER_LIST_NEXT_NBL((PNET_BUFFER_LIST)pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber]) = pIndicateRxPkts->NetBufferList;
                pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] ++;
            }

#if 0
            if ((pPort->CommonCfg.BACapability.field.AutoBA == FALSE) || (pPort->CommonCfg.PhyMode < PHY_11ABGN_MIXED))
            {
                Ndis6PlatformIndicatePktToNdis(pAd, (PVOID)pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber], pPort->PortNumber, pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber]);
                pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = NULL;
                pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] = NULL;
                pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] = 0;
            }
#endif          
            NdisReleaseSpinLock(&pAd->pRxCfg->IndicateRxPktsLock[pPort->PortNumber]);
        }
    }
#if 0   // If NOT use the flag as NDIS_RECEIVE_FLAGS_RESOURCES to Ndis, finish InsertTailQueue(IndicateRxPktsQueue) in N6ReturnNetBufferLists  
    NdisAcquireSpinLock(&pAd->pRxCfg->IndicateRxPktsQueueLock);
    InsertTailQueue(&pAd->pRxCfg->IndicateRxPktsQueue, pIndicateRxPkts);
    NdisReleaseSpinLock(&pAd->pRxCfg->IndicateRxPktsQueueLock);
#endif  
    INC_COUNTER64(pAd->Counter.Counters8023.GoodReceives);
    DBGPRINT(RT_DEBUG_TRACE, ("Indicate Aggregate frame to OS \n"));
}

/*
    bSingleIndicate = FALSE --> aggregated indication (beside N6UsbRxStaPacket)
    bSingleIndicate = TRUE  --> single indication
*/
VOID
Ndis6CommonReportAMSDUEthFrameToLLC(
    IN  PMP_ADAPTER   pAd,
    IN  PMP_PORT      pPort,
    IN  PUCHAR          p80211DataFrame,
    IN  USHORT          us80211FrameSize,
    IN  UCHAR           UserPriority,
    IN  BOOLEAN         bSingleIndicate)
{
    PNET_BUFFER     NetBuffer;
    PMP_LOCAL_RX_PKTS pIndicateRxPkts = NULL;
    PHEADER_802_11  pHeader80211 = NULL;    
    BOOLEAN             FirstMSDU = TRUE;
    UCHAR           Save80211Hdr[LENGTH_802_11];
    ULONG   Payload1Size;
    ULONG   SubSize;
    ULONG   DataLen;
    PUCHAR  pDataPos;
    PQUEUE_HEADER   pQueue;
    NDIS_NET_BUFFER_LIST_8021Q_INFO     Ndis8021QInfo;

    DBGPRINT(RT_DEBUG_INFO, ("Ndis6CommonReportAMSDUEthFrameToLLC\n"));

    NdisAcquireSpinLock(&pAd->pRxCfg->IndicateRxPktsQueueLock);
    pQueue = (PQUEUE_HEADER) &pAd->pRxCfg->IndicateRxPktsQueue;
    if (pQueue->Head != NULL)
        pIndicateRxPkts = (PMP_LOCAL_RX_PKTS)RemoveHeadQueue(pQueue);
    NdisReleaseSpinLock(&pAd->pRxCfg->IndicateRxPktsQueueLock);

    if (pIndicateRxPkts == NULL)
    {
        DBGPRINT(RT_DEBUG_ERROR, ("Ndis6CommonReportAMSDUEthFrameToLLC failed!\n"));
        return;
    }

    pDataPos = p80211DataFrame;
    DataLen = us80211FrameSize - LENGTH_802_11;
    pDataPos += LENGTH_802_11;

    while (DataLen > LENGTH_802_3)
    {
        Payload1Size = pDataPos[13] + ((pDataPos[12])<<8);
        pDataPos += LENGTH_802_3;
        SubSize = Payload1Size + LENGTH_802_3;
        if ((DataLen < SubSize) || (Payload1Size == 0))
        {
            DBGPRINT(RT_DEBUG_TRACE,("A-MSDU!break;.Payload1Size = %d. TotalDataLen = %d\n", Payload1Size, DataLen));
            break;
        }

        if (PlatformEqualMemory(SNAP_802_1H, pDataPos,6))
        {
            if (FirstMSDU)
            {
                FirstMSDU = FALSE;

                //
                // Trim the sub-frame header
                //
                PlatformMoveMemory(Save80211Hdr, p80211DataFrame, LENGTH_802_11);
                RtlMoveMemory(pDataPos - LENGTH_802_11, p80211DataFrame, LENGTH_802_11);

                Ndis6CommonFillReceiveContext(pAd, pPort, &pIndicateRxPkts->Dot11RecvContext,0);
                NetBuffer = NET_BUFFER_LIST_FIRST_NB((PNET_BUFFER_LIST)pIndicateRxPkts->NetBufferList);

                NET_BUFFER_DATA_LENGTH(NetBuffer) = Payload1Size + LENGTH_802_11;

                MmInitializeMdl((PMDL)pIndicateRxPkts->Mdl, pDataPos - LENGTH_802_11, Payload1Size + LENGTH_802_11);
                MmBuildMdlForNonPagedPool((PMDL)pIndicateRxPkts->Mdl);

                NdisAdjustMdlLength((PMDL)pIndicateRxPkts->Mdl, Payload1Size + LENGTH_802_11); 
                
                MT_SET_NETBUFFERLIST_IN_NBL(pIndicateRxPkts->NetBufferList, pIndicateRxPkts);
                MT_SET_RECEIVE_CONTEXT(pIndicateRxPkts->NetBufferList, &pIndicateRxPkts->Dot11RecvContext);

                //user priority
                Ndis8021QInfo.Value = 0;
                Ndis8021QInfo.WLanTagHeader.WMMInfo = UserPriority;
                NET_BUFFER_LIST_INFO(pIndicateRxPkts->NetBufferList, Ieee8021QNetBufferListInfo) = Ndis8021QInfo.Value; 

                //
                // We only indicate One Net Buffer List here.
                //
                NET_BUFFER_LIST_NEXT_NBL(pIndicateRxPkts->NetBufferList) = NULL;

                //
                // We can only indicate receive packet when the adpater state is in Nic running state
                // Otherwise, it will cause problem when we indicate at wrong time.
                //
                if (pAd->AdapterState == NicRunning)
                {
#if 0
                    NdisMIndicateReceiveNetBufferLists(pAd->AdapterHandle,
                                                    pIndicateRxPkts->NetBufferList,
                                                    pPort->PortNumber,
                                                    1,
                                                    NDIS_RECEIVE_FLAGS_RESOURCES);
#endif
                    if (pAd->pHifCfg->bBulkInRead == TRUE || bSingleIndicate == TRUE)
                    {
                        PlatformIndicatePktToNdis(pAd, (PVOID)pIndicateRxPkts->NetBufferList, pPort->PortNumber, 1);
                    }
                    else
                    {
                        NdisAcquireSpinLock(&pAd->pRxCfg->IndicateRxPktsLock[pPort->PortNumber]);
                        if (pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] == NULL)
                        {
                            pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                            pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                            pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] = 1;
                        }
                        else
                        {
                            NET_BUFFER_LIST_NEXT_NBL((PNET_BUFFER_LIST)pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber]) = pIndicateRxPkts->NetBufferList;
                            pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                            pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] ++;
                        }

#if 0
                        if ((pPort->CommonCfg.BACapability.field.AutoBA == FALSE) || (pPort->CommonCfg.PhyMode < PHY_11ABGN_MIXED))
                        {
                            Ndis6PlatformIndicatePktToNdis(pAd, (PVOID)pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber], pPort->PortNumber, pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber]);
                            pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = NULL;
                            pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] = NULL;
                            pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] = 0;
                        }
#endif                      
                        NdisReleaseSpinLock(&pAd->pRxCfg->IndicateRxPktsLock[pPort->PortNumber]);
                    }
                }
            }
            else
            {
                //
                // Make 802.11 Header + Data continuous
                //
                PlatformMoveMemory(pDataPos - LENGTH_802_11, Save80211Hdr, LENGTH_802_11);
                Ndis6CommonFillReceiveContext(pAd, pPort, &pIndicateRxPkts->Dot11RecvContext,0);
                NetBuffer = NET_BUFFER_LIST_FIRST_NB(pIndicateRxPkts->NetBufferList);

                NET_BUFFER_DATA_LENGTH(NetBuffer) = Payload1Size + LENGTH_802_11;

                MmInitializeMdl(pIndicateRxPkts->Mdl, pDataPos - LENGTH_802_11, Payload1Size + LENGTH_802_11);
                MmBuildMdlForNonPagedPool(pIndicateRxPkts->Mdl);

                NdisAdjustMdlLength(pIndicateRxPkts->Mdl, Payload1Size + LENGTH_802_11); 
                
                MT_SET_NETBUFFERLIST_IN_NBL(pIndicateRxPkts->NetBufferList, pIndicateRxPkts);
                MT_SET_RECEIVE_CONTEXT(pIndicateRxPkts->NetBufferList, &pIndicateRxPkts->Dot11RecvContext);

                //user priority
                Ndis8021QInfo.Value = 0;
                Ndis8021QInfo.WLanTagHeader.WMMInfo = UserPriority;
                NET_BUFFER_LIST_INFO(pIndicateRxPkts->NetBufferList, Ieee8021QNetBufferListInfo) = Ndis8021QInfo.Value; 

                //
                // We only indicate One Net Buffer List here.
                //
                NET_BUFFER_LIST_NEXT_NBL(pIndicateRxPkts->NetBufferList) = NULL;

                //
                // We can only indicate receive packet when the adpater state is in Nic running state
                // Otherwise, it will cause problem when we indicate at wrong time.
                //
                if (pAd->AdapterState == NicRunning)
                {
#if 0
                    NdisMIndicateReceiveNetBufferLists(pAd->AdapterHandle,
                                                    pIndicateRxPkts->NetBufferList,
                                                    pPort->PortNumber,
                                                    1,
                                                    NDIS_RECEIVE_FLAGS_RESOURCES);
#endif
                    if (pAd->pHifCfg->bBulkInRead == TRUE || bSingleIndicate == TRUE)
                    {
                        PlatformIndicatePktToNdis(pAd, (PVOID)pIndicateRxPkts->NetBufferList, pPort->PortNumber, 1);
                    }
                    else
                    {
                        NdisAcquireSpinLock(&pAd->pRxCfg->IndicateRxPktsLock[pPort->PortNumber]);
                        if (pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] == NULL)
                        {
                            pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                            pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                            pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] = 1;
                        }
                        else
                        {
                            NET_BUFFER_LIST_NEXT_NBL((PNET_BUFFER_LIST)pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber]) = pIndicateRxPkts->NetBufferList;
                            pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = (PVOID)pIndicateRxPkts->NetBufferList;
                            pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] ++;
                        }

#if 0
                        if ((pPort->CommonCfg.BACapability.field.AutoBA == FALSE) || (pPort->CommonCfg.PhyMode < PHY_11ABGN_MIXED))
                        {
                            Ndis6PlatformIndicatePktToNdis(pAd, (PVOID)pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber], pPort->PortNumber, pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber]);
                            pAd->pRxCfg->pLastWaitToIndicateRxPkts[pPort->PortNumber] = NULL;
                            pAd->pRxCfg->pWaitToIndicateRxPkts[pPort->PortNumber] = NULL;
                            pAd->pRxCfg->nWaitToIndicateRxPktsNum[pPort->PortNumber] = 0;
                        }
#endif                      
                        NdisReleaseSpinLock(&pAd->pRxCfg->IndicateRxPktsLock[pPort->PortNumber]);
                    }
                }
            }
        }
        else
        {
            DBGPRINT(RT_DEBUG_TRACE,("A-MSDU!No SNAP LLC format \n"));
        }

        while((SubSize % 4) != 0)
        {
            SubSize++;
            Payload1Size++;
        }

        if (DataLen < SubSize)
            break;

        DataLen -= SubSize;
        pDataPos += Payload1Size;
    }

#if 0   // If NOT use the flag as NDIS_RECEIVE_FLAGS_RESOURCES to Ndis, finish InsertTailQueue(IndicateRxPktsQueue) in N6ReturnNetBufferLists
    NdisAcquireSpinLock(&pAd->pRxCfg->IndicateRxPktsQueueLock);
    InsertTailQueue(&pAd->pRxCfg->IndicateRxPktsQueue, pIndicateRxPkts);
    NdisReleaseSpinLock(&pAd->pRxCfg->IndicateRxPktsQueueLock);

    MT_DEC_REF(&pAd->pRxCfg->nIndicatedRxPkts);
#endif  
}